#include <poponnx/chains.hpp>
#include <poponnx/ir.hpp>
#include <poponnx/names.hpp>
#include <poponnx/op.hpp>
#include <poponnx/tensor.hpp>
#include <poponnx/tensors.hpp>

namespace poponnx {

std::map<Tensor *, view::Chains> Tensors::aliasChainsTo(Tensor *to) const {

  auto found = aliases.find(to);
  if (found == aliases.end()) {
    return {{to, view::Chains::getIdentity(to->info.shape())}};
  }

  else {
    auto retM = found->second;
    retM[to]  = view::Chains::getIdentity(to->info.shape());
    return retM;
  }
}

std::map<Tensor *, view::Chains> Tensors::aliasChainsFrom(Tensor *) const {
  throw error("Tensors::aliasChainsFrom needs implementing");
}

void Tensors::updateAliases(Op *op) {

  // there is no aliasing for ops with more than 1 output,
  if (op->output->n() == 1 && op->output->hasIndex(0)) {

    Tensor *t2 = op->output->tensor(0);

    for (auto i1_t1 : op->input->tensorMap()) {

      InIndex i1 = i1_t1.first;
      Tensor *t1 = i1_t1.second;

      auto fwdMap = op->fwdRegMap(i1);
      auto bwdMap = op->bwdRegMap(i1);

      view::Region inRegion  = op->aliases(i1);
      view::Region outRegion = fwdMap(inRegion);

      view::Link fwdLink(inRegion, fwdMap);
      view::Link bwdLink(outRegion, bwdMap);

      if (!outRegion.isEmpty()) {

        auto chainsIn  = aliasChainsTo(t1);
        auto chainsOut = aliasChainsFrom(t2);

        for (auto &inwards : chainsIn) {
          Tensor *t0            = inwards.first;
          view::Chains inChains = inwards.second;

          for (auto &outwards : chainsOut) {
            Tensor *t3             = outwards.first;
            view::Chains outChains = outwards.second;

            // we now have,
            // t0 ------> t1 -> op -> t2 -----> t3
            // and we want to update aliases[t3][t0]
            // with and new chains that pass through op.

            if (aliases.find(t3) == aliases.end()) {
              aliases[t3] = {};
            }
            if (aliases.at(t3).find(t0) == aliases.at(t3).end()) {
              aliases[t3][t0] = {}; // empty Chains
            }
            // add the new Chains. This needs implementation
            aliases[t3][t0] = aliases[t3][t0].parallel(
                inChains.series(fwdLink).series(outChains));
          }
        }
      }
    }
  }
}

std::vector<TensorId> Tensors::getAllTensorIds() const {
  std::vector<TensorId> allIds;
  allIds.reserve(M.size());
  for (auto &id_tensor : M) {
    allIds.push_back(id_tensor.first);
  }
  return allIds;
}

// remove all Tensors with no producer and no consumers
void Tensors::removeIsolated() {
  for (auto &id : getAllTensorIds()) {
    Tensor *tensor = M[id].get();
    if (tensor->hasProducer() == false && tensor->consumers.getTotal() == 0) {
      M.erase(id);
      logging::ir::debug("Removing isolated Tensor {}", id);
    }
  }
}

std::vector<TensorId> Tensors::getIds(TensorType type) const {
  std::vector<TensorId> ids;
  for (auto &id_pt : M) {
    if (id_pt.second->tensorType() == type) {
      ids.push_back(id_pt.first);
    }
  }
  return ids;
}

Tensors::Tensors(Ir &pg) : ir(pg) {}

Tensor *Tensors::get(TensorId tenId) const {
  auto found = M.find(tenId);
  if (found == M.end()) {
    throw error("no tensor with id " + tenId);
  }
  return found->second.get();
}

void Tensors::append(std::stringstream &ss) const {
  bool frst = true;
  ss << '[';
  for (auto &id_ptr : M) {
    if (!frst) {
      ss << ' ';
    }
    frst = false;
    ss << id_ptr.first;
  }
  ss << ']';
}

std::vector<TensorId> Tensors::getNoProducerIds() const {
  // the tensors which are not generated by an Op
  std::vector<TensorId> t0 = getIds(TensorType::Stream);
  std::vector<TensorId> t1 = getIds(TensorType::Const);
  std::vector<TensorId> t2 = getIds(TensorType::Variable);
  t0.insert(t0.end(), t1.begin(), t1.end());
  t0.insert(t0.end(), t2.begin(), t2.end());
  return t0;
}

void Tensors::insert(TensorId name, std::unique_ptr<Tensor> t) {
  if (M.find(name) != M.end()) {
    throw error("ILE : tensor " + name + " already in M");
  }
  M[name] = std::move(t);
}

void Tensors::addConstInit(const TensorId &name, const onnx::TensorProto *pt) {
  addInit(name, pt, TensorType::Const);
  insertConstId(name);
}

void Tensors::addVarInit(const TensorId &name, const onnx::TensorProto *pt) {
  addInit(name, pt, TensorType::Variable);

  // A sanity check: if the tensor is fixed point, it is Const
  if (get(name)->info.getDataTypeInfo()->isFixedPoint()) {
    if (!constIds.contains(name)) {
      std::stringstream ss;
      ss << "A fixed-point Variable tensor `" << name
         << "'. Currently only floating-point tensors can be Variable. "
         << " Consider setting fixed-point tensors to be outputs of Constant "
         << "Ops, using (for example) "
         << "convertAllFixedPointInitializersToConstants().";
      throw error(ss.str());
    }
  }
}
void Tensors::addConstInit(const TensorId &name,
                           const TensorInfo &info,
                           const void *src) {
  insert(name,
         std::unique_ptr<Tensor>(new Tensor(name, TensorType::Const, ir)));

  insertConstId(name);

  Tensor *init = get(name);
  init->info   = info;
  init->setTensorData(info, src);
}

void Tensors::addInit(const TensorId &name,
                      const onnx::TensorProto *pt,
                      TensorType tt) {

  insert(name, std::unique_ptr<Tensor>(new Tensor(name, tt, ir)));
  Tensor *init = get(name);
  init->info   = TensorInfo(*pt);
  init->setTensorData(*pt);
}

void Tensors::addStream(TensorId tenId, const TensorInfo &info) {
  insert(tenId,
         std::unique_ptr<Tensor>(new Tensor(tenId, TensorType::Stream, ir)));
  get(tenId)->info = info;
}

void Tensors::addActGrad(TensorId tenId) {
  insert(tenId,
         std::unique_ptr<Tensor>(new Tensor(tenId, TensorType::ActGrad, ir)));
}

void Tensors::remove(TensorId id) { M.erase(id); }

bool Tensors::contains(TensorId id) const { return M.find(id) != M.end(); }

void Tensors::insertConstId(const std::string &id) { constIds.insert(id); }

} // namespace poponnx
