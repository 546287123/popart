/*
 * THIS IS AN AUTOGENERATED FILE, DO NOT EDIT DIRECTLY
 *
 * To regenerated ths file run the gen_operators.py script
 */
py::class_<AiOnnxOpset6>(m, "AiOnnxOpset6")
  .def("abs",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.abs(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("add",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<int64_t> axis,
          int64_t broadcast,
          const std::string &name) -> TensorId{
           return opset.add(args,
                            axis,
                            broadcast,
                            name);
       },
       py::arg("args"),
       py::arg("axis") = nonstd::optional<int64_t>(),
       py::arg("broadcast") = 0,
       py::arg("debugPrefix") = std::string())
  .def("logical_and",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<int64_t> axis,
          int64_t broadcast,
          const std::string &name) -> TensorId{
           return opset.logical_and(args,
                                    axis,
                                    broadcast,
                                    name);
       },
       py::arg("args"),
       py::arg("axis") = nonstd::optional<int64_t>(),
       py::arg("broadcast") = 0,
       py::arg("debugPrefix") = std::string())
  .def("argmax",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.argmax(args,
                               axis,
                               keepdims,
                               name);
       },
       py::arg("args"),
       py::arg("axis") = 0,
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("argmin",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.argmin(args,
                               axis,
                               keepdims,
                               name);
       },
       py::arg("args"),
       py::arg("axis") = 0,
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("averagepool",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& kernel_shape,
          const std::vector<int64_t>& pads,
          const std::vector<int64_t>& strides,
          const std::string &name) -> TensorId{
           return opset.averagepool(args,
                                    kernel_shape,
                                    pads,
                                    strides,
                                    name);
       },
       py::arg("args"),
       py::arg("kernel_shape"),
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("batchnormalization",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          float epsilon,
          int64_t is_test,
          float momentum,
          int64_t spatial,
          const std::string &name) -> std::vector<TensorId>{
           return opset.batchnormalization(args,
                                           num_outputs,
                                           epsilon,
                                           is_test,
                                           momentum,
                                           spatial,
                                           name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("epsilon") = 1e-05f,
       py::arg("is_test") = 0,
       py::arg("momentum") = 0.9f,
       py::arg("spatial") = 1,
       py::arg("debugPrefix") = std::string())
  .def("cast",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::string& to,
          const std::string &name) -> TensorId{
           return opset.cast(args,
                             to,
                             name);
       },
       py::arg("args"),
       py::arg("to"),
       py::arg("debugPrefix") = std::string())
  .def("ceil",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.ceil(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("clip",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          float max,
          float min,
          const std::string &name) -> TensorId{
           return opset.clip(args,
                             max,
                             min,
                             name);
       },
       py::arg("args"),
       py::arg("max") = 3.4028234663852886e+38f,
       py::arg("min") = -3.4028234663852886e+38f,
       py::arg("debugPrefix") = std::string())
  .def("concat",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.concat(args,
                               axis,
                               name);
       },
       py::arg("args"),
       py::arg("axis"),
       py::arg("debugPrefix") = std::string())
  .def("constant",
       [](AiOnnxOpset6 &opset, py::array array, const std::string& name) {
          array = makeContiguous(array);
          ConstVoidData initData;
          initData.data = array.request().ptr;
          initData.info = getTensorInfo(array);
          return opset.constant(initData, name);
        },
       py::arg("value"),
       py::arg("debugPrefix") = std::string())
  .def("conv",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& dilations,
          int64_t group,
          const std::vector<int64_t>& kernel_shape,
          const std::vector<int64_t>& pads,
          const std::vector<int64_t>& strides,
          const std::string &name) -> TensorId{
           return opset.conv(args,
                             dilations,
                             group,
                             kernel_shape,
                             pads,
                             strides,
                             name);
       },
       py::arg("args"),
       py::arg("dilations") = std::vector<int64_t>(),
       py::arg("group") = 1,
       py::arg("kernel_shape") = std::vector<int64_t>(),
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("convtranspose",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& dilations,
          int64_t group,
          const std::vector<int64_t>& kernel_shape,
          const std::vector<int64_t>& output_padding,
          const std::vector<int64_t>& output_shape,
          const std::vector<int64_t>& pads,
          const std::vector<int64_t>& strides,
          const std::string &name) -> TensorId{
           return opset.convtranspose(args,
                                      dilations,
                                      group,
                                      kernel_shape,
                                      output_padding,
                                      output_shape,
                                      pads,
                                      strides,
                                      name);
       },
       py::arg("args"),
       py::arg("dilations") = std::vector<int64_t>(),
       py::arg("group") = 1,
       py::arg("kernel_shape") = std::vector<int64_t>(),
       py::arg("output_padding") = std::vector<int64_t>(),
       py::arg("output_shape") = std::vector<int64_t>(),
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("depthtospace",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          int64_t blocksize,
          const std::string &name) -> TensorId{
           return opset.depthtospace(args,
                                     blocksize,
                                     name);
       },
       py::arg("args"),
       py::arg("blocksize"),
       py::arg("debugPrefix") = std::string())
  .def("div",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<int64_t> axis,
          int64_t broadcast,
          const std::string &name) -> TensorId{
           return opset.div(args,
                            axis,
                            broadcast,
                            name);
       },
       py::arg("args"),
       py::arg("axis") = nonstd::optional<int64_t>(),
       py::arg("broadcast") = 0,
       py::arg("debugPrefix") = std::string())
  .def("dropout",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          int64_t is_test,
          float ratio,
          const std::string &name) -> std::vector<TensorId>{
           return opset.dropout(args,
                                num_outputs,
                                is_test,
                                ratio,
                                name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("is_test") = 0,
       py::arg("ratio") = 0.5f,
       py::arg("debugPrefix") = std::string())
  .def("elu",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          float alpha,
          const std::string &name) -> TensorId{
           return opset.elu(args,
                            alpha,
                            name);
       },
       py::arg("args"),
       py::arg("alpha") = 1.0f,
       py::arg("debugPrefix") = std::string())
  .def("equal",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<int64_t> axis,
          int64_t broadcast,
          const std::string &name) -> TensorId{
           return opset.equal(args,
                              axis,
                              broadcast,
                              name);
       },
       py::arg("args"),
       py::arg("axis") = nonstd::optional<int64_t>(),
       py::arg("broadcast") = 0,
       py::arg("debugPrefix") = std::string())
  .def("exp",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.exp(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("flatten",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.flatten(args,
                                axis,
                                name);
       },
       py::arg("args"),
       py::arg("axis") = 1,
       py::arg("debugPrefix") = std::string())
  .def("floor",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.floor(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("gru",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const std::vector<float>& activation_alpha,
          const std::vector<float>& activation_beta,
          const std::vector<std::string>& activations,
          nonstd::optional<float> clip,
          const std::string& direction,
          nonstd::optional<int64_t> hidden_size,
          int64_t linear_before_reset,
          int64_t output_sequence,
          const std::string &name) -> std::vector<TensorId>{
           return opset.gru(args,
                            num_outputs,
                            activation_alpha,
                            activation_beta,
                            activations,
                            clip,
                            direction,
                            hidden_size,
                            linear_before_reset,
                            output_sequence,
                            name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("activation_alpha") = std::vector<float>(),
       py::arg("activation_beta") = std::vector<float>(),
       py::arg("activations") = std::vector<std::string>(),
       py::arg("clip") = nonstd::optional<float>(),
       py::arg("direction") = "forward",
       py::arg("hidden_size") = nonstd::optional<int64_t>(),
       py::arg("linear_before_reset") = 0,
       py::arg("output_sequence") = 0,
       py::arg("debugPrefix") = std::string())
  .def("gather",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.gather(args,
                               axis,
                               name);
       },
       py::arg("args"),
       py::arg("axis") = 0,
       py::arg("debugPrefix") = std::string())
  .def("gemm",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          float alpha,
          float beta,
          int64_t broadcast,
          int64_t transA,
          int64_t transB,
          const std::string &name) -> TensorId{
           return opset.gemm(args,
                             alpha,
                             beta,
                             broadcast,
                             transA,
                             transB,
                             name);
       },
       py::arg("args"),
       py::arg("alpha") = 1.0f,
       py::arg("beta") = 1.0f,
       py::arg("broadcast") = 0,
       py::arg("transA") = 0,
       py::arg("transB") = 0,
       py::arg("debugPrefix") = std::string())
  .def("globalaveragepool",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.globalaveragepool(args,
                                          name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("globallppool",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          int64_t p,
          const std::string &name) -> TensorId{
           return opset.globallppool(args,
                                     p,
                                     name);
       },
       py::arg("args"),
       py::arg("p") = 2,
       py::arg("debugPrefix") = std::string())
  .def("globalmaxpool",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.globalmaxpool(args,
                                      name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("greater",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<int64_t> axis,
          int64_t broadcast,
          const std::string &name) -> TensorId{
           return opset.greater(args,
                                axis,
                                broadcast,
                                name);
       },
       py::arg("args"),
       py::arg("axis") = nonstd::optional<int64_t>(),
       py::arg("broadcast") = 0,
       py::arg("debugPrefix") = std::string())
  .def("hardsigmoid",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          float alpha,
          float beta,
          const std::string &name) -> TensorId{
           return opset.hardsigmoid(args,
                                    alpha,
                                    beta,
                                    name);
       },
       py::arg("args"),
       py::arg("alpha") = 0.2f,
       py::arg("beta") = 0.5f,
       py::arg("debugPrefix") = std::string())
  .def("hardmax",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.hardmax(args,
                                axis,
                                name);
       },
       py::arg("args"),
       py::arg("axis") = 1,
       py::arg("debugPrefix") = std::string())
  .def("identity",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.identity(args,
                                 name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("logical_if",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const Builder& else_branch,
          const Builder& then_branch,
          const std::string &name) -> std::vector<TensorId>{
           return opset.logical_if(args,
                                   num_outputs,
                                   else_branch,
                                   then_branch,
                                   name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("else_branch"),
       py::arg("then_branch"),
       py::arg("debugPrefix") = std::string())
  .def("instancenormalization",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          float epsilon,
          const std::string &name) -> TensorId{
           return opset.instancenormalization(args,
                                              epsilon,
                                              name);
       },
       py::arg("args"),
       py::arg("epsilon") = 1e-05f,
       py::arg("debugPrefix") = std::string())
  .def("lrn",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          int64_t size,
          float alpha,
          float beta,
          float bias,
          const std::string &name) -> TensorId{
           return opset.lrn(args,
                            size,
                            alpha,
                            beta,
                            bias,
                            name);
       },
       py::arg("args"),
       py::arg("size"),
       py::arg("alpha") = 0.0001f,
       py::arg("beta") = 0.75f,
       py::arg("bias") = 1.0f,
       py::arg("debugPrefix") = std::string())
  .def("lstm",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const std::vector<float>& activation_alpha,
          const std::vector<float>& activation_beta,
          const std::vector<std::string>& activations,
          nonstd::optional<float> clip,
          const std::string& direction,
          nonstd::optional<int64_t> hidden_size,
          int64_t input_forget,
          int64_t output_sequence,
          const std::string &name) -> std::vector<TensorId>{
           return opset.lstm(args,
                             num_outputs,
                             activation_alpha,
                             activation_beta,
                             activations,
                             clip,
                             direction,
                             hidden_size,
                             input_forget,
                             output_sequence,
                             name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("activation_alpha") = std::vector<float>(),
       py::arg("activation_beta") = std::vector<float>(),
       py::arg("activations") = std::vector<std::string>(),
       py::arg("clip") = nonstd::optional<float>(),
       py::arg("direction") = "forward",
       py::arg("hidden_size") = nonstd::optional<int64_t>(),
       py::arg("input_forget") = 0,
       py::arg("output_sequence") = 0,
       py::arg("debugPrefix") = std::string())
  .def("leakyrelu",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          float alpha,
          const std::string &name) -> TensorId{
           return opset.leakyrelu(args,
                                  alpha,
                                  name);
       },
       py::arg("args"),
       py::arg("alpha") = 0.01f,
       py::arg("debugPrefix") = std::string())
  .def("less",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<int64_t> axis,
          int64_t broadcast,
          const std::string &name) -> TensorId{
           return opset.less(args,
                             axis,
                             broadcast,
                             name);
       },
       py::arg("args"),
       py::arg("axis") = nonstd::optional<int64_t>(),
       py::arg("broadcast") = 0,
       py::arg("debugPrefix") = std::string())
  .def("log",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.log(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("logsoftmax",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.logsoftmax(args,
                                   axis,
                                   name);
       },
       py::arg("args"),
       py::arg("axis") = 1,
       py::arg("debugPrefix") = std::string())
  .def("loop",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const Builder& body,
          const std::string &name) -> std::vector<TensorId>{
           return opset.loop(args,
                             num_outputs,
                             body,
                             name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("body"),
       py::arg("debugPrefix") = std::string())
  .def("lpnormalization",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          int64_t p,
          const std::string &name) -> TensorId{
           return opset.lpnormalization(args,
                                        axis,
                                        p,
                                        name);
       },
       py::arg("args"),
       py::arg("axis") = -1,
       py::arg("p") = 2,
       py::arg("debugPrefix") = std::string())
  .def("lppool",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& kernel_shape,
          int64_t p,
          const std::vector<int64_t>& pads,
          const std::vector<int64_t>& strides,
          const std::string &name) -> TensorId{
           return opset.lppool(args,
                               kernel_shape,
                               p,
                               pads,
                               strides,
                               name);
       },
       py::arg("args"),
       py::arg("kernel_shape"),
       py::arg("p") = 2,
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("matmul",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.matmul(args,
                               name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("max",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.max(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("maxpool",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& kernel_shape,
          const std::vector<int64_t>& pads,
          const std::vector<int64_t>& strides,
          const std::string &name) -> TensorId{
           return opset.maxpool(args,
                                kernel_shape,
                                pads,
                                strides,
                                name);
       },
       py::arg("args"),
       py::arg("kernel_shape"),
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("maxroipool",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& pooled_shape,
          float spatial_scale,
          const std::string &name) -> TensorId{
           return opset.maxroipool(args,
                                   pooled_shape,
                                   spatial_scale,
                                   name);
       },
       py::arg("args"),
       py::arg("pooled_shape"),
       py::arg("spatial_scale") = 1.0f,
       py::arg("debugPrefix") = std::string())
  .def("mean",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.mean(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("min",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.min(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("mul",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<int64_t> axis,
          int64_t broadcast,
          const std::string &name) -> TensorId{
           return opset.mul(args,
                            axis,
                            broadcast,
                            name);
       },
       py::arg("args"),
       py::arg("axis") = nonstd::optional<int64_t>(),
       py::arg("broadcast") = 0,
       py::arg("debugPrefix") = std::string())
  .def("neg",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.neg(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("logical_not",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.logical_not(args,
                                    name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("logical_or",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<int64_t> axis,
          int64_t broadcast,
          const std::string &name) -> TensorId{
           return opset.logical_or(args,
                                   axis,
                                   broadcast,
                                   name);
       },
       py::arg("args"),
       py::arg("axis") = nonstd::optional<int64_t>(),
       py::arg("broadcast") = 0,
       py::arg("debugPrefix") = std::string())
  .def("prelu",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.prelu(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("pad",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& pads,
          const std::string& mode,
          float value,
          const std::string &name) -> TensorId{
           return opset.pad(args,
                            pads,
                            mode,
                            value,
                            name);
       },
       py::arg("args"),
       py::arg("pads"),
       py::arg("mode") = "constant",
       py::arg("value") = 0.0f,
       py::arg("debugPrefix") = std::string())
  .def("pow",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<int64_t> axis,
          int64_t broadcast,
          const std::string &name) -> TensorId{
           return opset.pow(args,
                            axis,
                            broadcast,
                            name);
       },
       py::arg("args"),
       py::arg("axis") = nonstd::optional<int64_t>(),
       py::arg("broadcast") = 0,
       py::arg("debugPrefix") = std::string())
  .def("rnn",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const std::vector<float>& activation_alpha,
          const std::vector<float>& activation_beta,
          const std::vector<std::string>& activations,
          nonstd::optional<float> clip,
          const std::string& direction,
          nonstd::optional<int64_t> hidden_size,
          int64_t output_sequence,
          const std::string &name) -> std::vector<TensorId>{
           return opset.rnn(args,
                            num_outputs,
                            activation_alpha,
                            activation_beta,
                            activations,
                            clip,
                            direction,
                            hidden_size,
                            output_sequence,
                            name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("activation_alpha") = std::vector<float>(),
       py::arg("activation_beta") = std::vector<float>(),
       py::arg("activations") = std::vector<std::string>(),
       py::arg("clip") = nonstd::optional<float>(),
       py::arg("direction") = "forward",
       py::arg("hidden_size") = nonstd::optional<int64_t>(),
       py::arg("output_sequence") = 0,
       py::arg("debugPrefix") = std::string())
  .def("randomnormal",
       [](AiOnnxOpset6 &opset,
          const std::vector<int64_t>& shape,
          int64_t dtype,
          float mean,
          float scale,
          nonstd::optional<float> seed,
          const std::string &name) -> TensorId{
           return opset.randomnormal(                                     shape,
                                     dtype,
                                     mean,
                                     scale,
                                     seed,
                                     name);
       },
       py::arg("shape"),
       py::arg("dtype") = 1,
       py::arg("mean") = 0.0f,
       py::arg("scale") = 1.0f,
       py::arg("seed") = nonstd::optional<float>(),
       py::arg("debugPrefix") = std::string())
  .def("randomnormallike",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<int64_t> dtype,
          float mean,
          float scale,
          nonstd::optional<float> seed,
          const std::string &name) -> TensorId{
           return opset.randomnormallike(args,
                                         dtype,
                                         mean,
                                         scale,
                                         seed,
                                         name);
       },
       py::arg("args"),
       py::arg("dtype") = nonstd::optional<int64_t>(),
       py::arg("mean") = 0.0f,
       py::arg("scale") = 1.0f,
       py::arg("seed") = nonstd::optional<float>(),
       py::arg("debugPrefix") = std::string())
  .def("randomuniform",
       [](AiOnnxOpset6 &opset,
          const std::vector<int64_t>& shape,
          int64_t dtype,
          float high,
          float low,
          nonstd::optional<float> seed,
          const std::string &name) -> TensorId{
           return opset.randomuniform(                                      shape,
                                      dtype,
                                      high,
                                      low,
                                      seed,
                                      name);
       },
       py::arg("shape"),
       py::arg("dtype") = 1,
       py::arg("high") = 1.0f,
       py::arg("low") = 0.0f,
       py::arg("seed") = nonstd::optional<float>(),
       py::arg("debugPrefix") = std::string())
  .def("randomuniformlike",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<int64_t> dtype,
          float high,
          float low,
          nonstd::optional<float> seed,
          const std::string &name) -> TensorId{
           return opset.randomuniformlike(args,
                                          dtype,
                                          high,
                                          low,
                                          seed,
                                          name);
       },
       py::arg("args"),
       py::arg("dtype") = nonstd::optional<int64_t>(),
       py::arg("high") = 1.0f,
       py::arg("low") = 0.0f,
       py::arg("seed") = nonstd::optional<float>(),
       py::arg("debugPrefix") = std::string())
  .def("reciprocal",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.reciprocal(args,
                                   name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("reducel1",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducel1(args,
                                 axes,
                                 keepdims,
                                 name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducel2",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducel2(args,
                                 axes,
                                 keepdims,
                                 name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducelogsum",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducelogsum(args,
                                     axes,
                                     keepdims,
                                     name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducelogsumexp",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducelogsumexp(args,
                                        axes,
                                        keepdims,
                                        name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducemax",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducemax(args,
                                  axes,
                                  keepdims,
                                  name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducemean",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducemean(args,
                                   axes,
                                   keepdims,
                                   name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducemin",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducemin(args,
                                  axes,
                                  keepdims,
                                  name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reduceprod",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reduceprod(args,
                                   axes,
                                   keepdims,
                                   name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducesum",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducesum(args,
                                  axes,
                                  keepdims,
                                  name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducesumsquare",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducesumsquare(args,
                                        axes,
                                        keepdims,
                                        name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("relu",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.relu(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("reshape",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.reshape(args,
                                name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("selu",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          float alpha,
          float gamma,
          const std::string &name) -> TensorId{
           return opset.selu(args,
                             alpha,
                             gamma,
                             name);
       },
       py::arg("args"),
       py::arg("alpha") = 1.67326f,
       py::arg("gamma") = 1.0507f,
       py::arg("debugPrefix") = std::string())
  .def("shape",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.shape(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("sigmoid",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sigmoid(args,
                                name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("size",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.size(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("slice",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& ends,
          const std::vector<int64_t>& starts,
          const std::vector<int64_t>& axes,
          const std::string &name) -> TensorId{
           return opset.slice(args,
                              ends,
                              starts,
                              axes,
                              name);
       },
       py::arg("args"),
       py::arg("ends"),
       py::arg("starts"),
       py::arg("axes") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("softmax",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.softmax(args,
                                axis,
                                name);
       },
       py::arg("args"),
       py::arg("axis") = 1,
       py::arg("debugPrefix") = std::string())
  .def("softplus",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.softplus(args,
                                 name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("softsign",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.softsign(args,
                                 name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("spacetodepth",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          int64_t blocksize,
          const std::string &name) -> TensorId{
           return opset.spacetodepth(args,
                                     blocksize,
                                     name);
       },
       py::arg("args"),
       py::arg("blocksize"),
       py::arg("debugPrefix") = std::string())
  .def("split",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          int64_t axis,
          const std::vector<int64_t>& split,
          const std::string &name) -> std::vector<TensorId>{
           return opset.split(args,
                              num_outputs,
                              axis,
                              split,
                              name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("axis") = 0,
       py::arg("split") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("sqrt",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sqrt(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("squeeze",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& axes,
          const std::string &name) -> TensorId{
           return opset.squeeze(args,
                                axes,
                                name);
       },
       py::arg("args"),
       py::arg("axes") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("sub",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<int64_t> axis,
          int64_t broadcast,
          const std::string &name) -> TensorId{
           return opset.sub(args,
                            axis,
                            broadcast,
                            name);
       },
       py::arg("args"),
       py::arg("axis") = nonstd::optional<int64_t>(),
       py::arg("broadcast") = 0,
       py::arg("debugPrefix") = std::string())
  .def("sum",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sum(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("tanh",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.tanh(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("tile",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.tile(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("topk",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          int64_t k,
          int64_t axis,
          const std::string &name) -> std::vector<TensorId>{
           return opset.topk(args,
                             k,
                             axis,
                             name);
       },
       py::arg("args"),
       py::arg("k"),
       py::arg("axis") = -1,
       py::arg("debugPrefix") = std::string())
  .def("transpose",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& perm,
          const std::string &name) -> TensorId{
           return opset.transpose(args,
                                  perm,
                                  name);
       },
       py::arg("args"),
       py::arg("perm") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("unsqueeze",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& axes,
          const std::string &name) -> TensorId{
           return opset.unsqueeze(args,
                                  axes,
                                  name);
       },
       py::arg("args"),
       py::arg("axes"),
       py::arg("debugPrefix") = std::string())
  .def("upsample",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          float height_scale,
          float width_scale,
          const std::string& mode,
          const std::string &name) -> TensorId{
           return opset.upsample(args,
                                 height_scale,
                                 width_scale,
                                 mode,
                                 name);
       },
       py::arg("args"),
       py::arg("height_scale"),
       py::arg("width_scale"),
       py::arg("mode") = "nearest",
       py::arg("debugPrefix") = std::string())
  .def("logical_xor",
       [](AiOnnxOpset6 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<int64_t> axis,
          int64_t broadcast,
          const std::string &name) -> TensorId{
           return opset.logical_xor(args,
                                    axis,
                                    broadcast,
                                    name);
       },
       py::arg("args"),
       py::arg("axis") = nonstd::optional<int64_t>(),
       py::arg("broadcast") = 0,
       py::arg("debugPrefix") = std::string())
;
py::class_<AiOnnxOpset7>(m, "AiOnnxOpset7")
  .def("abs",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.abs(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("acos",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.acos(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("add",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.add(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("logical_and",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.logical_and(args,
                                    name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("argmax",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.argmax(args,
                               axis,
                               keepdims,
                               name);
       },
       py::arg("args"),
       py::arg("axis") = 0,
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("argmin",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.argmin(args,
                               axis,
                               keepdims,
                               name);
       },
       py::arg("args"),
       py::arg("axis") = 0,
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("asin",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.asin(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("atan",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.atan(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("averagepool",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& kernel_shape,
          int64_t count_include_pad,
          const std::vector<int64_t>& pads,
          const std::vector<int64_t>& strides,
          const std::string &name) -> TensorId{
           return opset.averagepool(args,
                                    kernel_shape,
                                    count_include_pad,
                                    pads,
                                    strides,
                                    name);
       },
       py::arg("args"),
       py::arg("kernel_shape"),
       py::arg("count_include_pad") = 0,
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("batchnormalization",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          float epsilon,
          float momentum,
          int64_t spatial,
          const std::string &name) -> std::vector<TensorId>{
           return opset.batchnormalization(args,
                                           num_outputs,
                                           epsilon,
                                           momentum,
                                           spatial,
                                           name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("epsilon") = 1e-05f,
       py::arg("momentum") = 0.9f,
       py::arg("spatial") = 1,
       py::arg("debugPrefix") = std::string())
  .def("cast",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string& to,
          const std::string &name) -> TensorId{
           return opset.cast(args,
                             to,
                             name);
       },
       py::arg("args"),
       py::arg("to"),
       py::arg("debugPrefix") = std::string())
  .def("ceil",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.ceil(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("clip",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          float max,
          float min,
          const std::string &name) -> TensorId{
           return opset.clip(args,
                             max,
                             min,
                             name);
       },
       py::arg("args"),
       py::arg("max") = 3.4028234663852886e+38f,
       py::arg("min") = -3.4028234663852886e+38f,
       py::arg("debugPrefix") = std::string())
  .def("concat",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.concat(args,
                               axis,
                               name);
       },
       py::arg("args"),
       py::arg("axis"),
       py::arg("debugPrefix") = std::string())
  .def("constant",
       [](AiOnnxOpset7 &opset, py::array array, const std::string& name) {
          array = makeContiguous(array);
          ConstVoidData initData;
          initData.data = array.request().ptr;
          initData.info = getTensorInfo(array);
          return opset.constant(initData, name);
        },
       py::arg("value"),
       py::arg("debugPrefix") = std::string())
  .def("conv",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& dilations,
          int64_t group,
          const std::vector<int64_t>& kernel_shape,
          const std::vector<int64_t>& pads,
          const std::vector<int64_t>& strides,
          const std::string &name) -> TensorId{
           return opset.conv(args,
                             dilations,
                             group,
                             kernel_shape,
                             pads,
                             strides,
                             name);
       },
       py::arg("args"),
       py::arg("dilations") = std::vector<int64_t>(),
       py::arg("group") = 1,
       py::arg("kernel_shape") = std::vector<int64_t>(),
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("convtranspose",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& dilations,
          int64_t group,
          const std::vector<int64_t>& kernel_shape,
          const std::vector<int64_t>& output_padding,
          const std::vector<int64_t>& output_shape,
          const std::vector<int64_t>& pads,
          const std::vector<int64_t>& strides,
          const std::string &name) -> TensorId{
           return opset.convtranspose(args,
                                      dilations,
                                      group,
                                      kernel_shape,
                                      output_padding,
                                      output_shape,
                                      pads,
                                      strides,
                                      name);
       },
       py::arg("args"),
       py::arg("dilations") = std::vector<int64_t>(),
       py::arg("group") = 1,
       py::arg("kernel_shape") = std::vector<int64_t>(),
       py::arg("output_padding") = std::vector<int64_t>(),
       py::arg("output_shape") = std::vector<int64_t>(),
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("cos",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.cos(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("depthtospace",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          int64_t blocksize,
          const std::string &name) -> TensorId{
           return opset.depthtospace(args,
                                     blocksize,
                                     name);
       },
       py::arg("args"),
       py::arg("blocksize"),
       py::arg("debugPrefix") = std::string())
  .def("div",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.div(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("dropout",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          float ratio,
          const std::string &name) -> std::vector<TensorId>{
           return opset.dropout(args,
                                num_outputs,
                                ratio,
                                name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("ratio") = 0.5f,
       py::arg("debugPrefix") = std::string())
  .def("elu",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          float alpha,
          const std::string &name) -> TensorId{
           return opset.elu(args,
                            alpha,
                            name);
       },
       py::arg("args"),
       py::arg("alpha") = 1.0f,
       py::arg("debugPrefix") = std::string())
  .def("equal",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.equal(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("exp",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.exp(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("flatten",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.flatten(args,
                                axis,
                                name);
       },
       py::arg("args"),
       py::arg("axis") = 1,
       py::arg("debugPrefix") = std::string())
  .def("floor",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.floor(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("gru",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const std::vector<float>& activation_alpha,
          const std::vector<float>& activation_beta,
          const std::vector<std::string>& activations,
          nonstd::optional<float> clip,
          const std::string& direction,
          nonstd::optional<int64_t> hidden_size,
          int64_t linear_before_reset,
          const std::string &name) -> std::vector<TensorId>{
           return opset.gru(args,
                            num_outputs,
                            activation_alpha,
                            activation_beta,
                            activations,
                            clip,
                            direction,
                            hidden_size,
                            linear_before_reset,
                            name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("activation_alpha") = std::vector<float>(),
       py::arg("activation_beta") = std::vector<float>(),
       py::arg("activations") = std::vector<std::string>(),
       py::arg("clip") = nonstd::optional<float>(),
       py::arg("direction") = "forward",
       py::arg("hidden_size") = nonstd::optional<int64_t>(),
       py::arg("linear_before_reset") = 0,
       py::arg("debugPrefix") = std::string())
  .def("gather",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.gather(args,
                               axis,
                               name);
       },
       py::arg("args"),
       py::arg("axis") = 0,
       py::arg("debugPrefix") = std::string())
  .def("gemm",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          float alpha,
          float beta,
          int64_t transA,
          int64_t transB,
          const std::string &name) -> TensorId{
           return opset.gemm(args,
                             alpha,
                             beta,
                             transA,
                             transB,
                             name);
       },
       py::arg("args"),
       py::arg("alpha") = 1.0f,
       py::arg("beta") = 1.0f,
       py::arg("transA") = 0,
       py::arg("transB") = 0,
       py::arg("debugPrefix") = std::string())
  .def("globalaveragepool",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.globalaveragepool(args,
                                          name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("globallppool",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          int64_t p,
          const std::string &name) -> TensorId{
           return opset.globallppool(args,
                                     p,
                                     name);
       },
       py::arg("args"),
       py::arg("p") = 2,
       py::arg("debugPrefix") = std::string())
  .def("globalmaxpool",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.globalmaxpool(args,
                                      name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("greater",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.greater(args,
                                name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("hardsigmoid",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          float alpha,
          float beta,
          const std::string &name) -> TensorId{
           return opset.hardsigmoid(args,
                                    alpha,
                                    beta,
                                    name);
       },
       py::arg("args"),
       py::arg("alpha") = 0.2f,
       py::arg("beta") = 0.5f,
       py::arg("debugPrefix") = std::string())
  .def("hardmax",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.hardmax(args,
                                axis,
                                name);
       },
       py::arg("args"),
       py::arg("axis") = 1,
       py::arg("debugPrefix") = std::string())
  .def("identity",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.identity(args,
                                 name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("logical_if",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const Builder& else_branch,
          const Builder& then_branch,
          const std::string &name) -> std::vector<TensorId>{
           return opset.logical_if(args,
                                   num_outputs,
                                   else_branch,
                                   then_branch,
                                   name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("else_branch"),
       py::arg("then_branch"),
       py::arg("debugPrefix") = std::string())
  .def("instancenormalization",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          float epsilon,
          const std::string &name) -> TensorId{
           return opset.instancenormalization(args,
                                              epsilon,
                                              name);
       },
       py::arg("args"),
       py::arg("epsilon") = 1e-05f,
       py::arg("debugPrefix") = std::string())
  .def("lrn",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          int64_t size,
          float alpha,
          float beta,
          float bias,
          const std::string &name) -> TensorId{
           return opset.lrn(args,
                            size,
                            alpha,
                            beta,
                            bias,
                            name);
       },
       py::arg("args"),
       py::arg("size"),
       py::arg("alpha") = 0.0001f,
       py::arg("beta") = 0.75f,
       py::arg("bias") = 1.0f,
       py::arg("debugPrefix") = std::string())
  .def("lstm",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const std::vector<float>& activation_alpha,
          const std::vector<float>& activation_beta,
          const std::vector<std::string>& activations,
          nonstd::optional<float> clip,
          const std::string& direction,
          nonstd::optional<int64_t> hidden_size,
          int64_t input_forget,
          const std::string &name) -> std::vector<TensorId>{
           return opset.lstm(args,
                             num_outputs,
                             activation_alpha,
                             activation_beta,
                             activations,
                             clip,
                             direction,
                             hidden_size,
                             input_forget,
                             name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("activation_alpha") = std::vector<float>(),
       py::arg("activation_beta") = std::vector<float>(),
       py::arg("activations") = std::vector<std::string>(),
       py::arg("clip") = nonstd::optional<float>(),
       py::arg("direction") = "forward",
       py::arg("hidden_size") = nonstd::optional<int64_t>(),
       py::arg("input_forget") = 0,
       py::arg("debugPrefix") = std::string())
  .def("leakyrelu",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          float alpha,
          const std::string &name) -> TensorId{
           return opset.leakyrelu(args,
                                  alpha,
                                  name);
       },
       py::arg("args"),
       py::arg("alpha") = 0.01f,
       py::arg("debugPrefix") = std::string())
  .def("less",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.less(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("log",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.log(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("logsoftmax",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.logsoftmax(args,
                                   axis,
                                   name);
       },
       py::arg("args"),
       py::arg("axis") = 1,
       py::arg("debugPrefix") = std::string())
  .def("loop",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const Builder& body,
          const std::string &name) -> std::vector<TensorId>{
           return opset.loop(args,
                             num_outputs,
                             body,
                             name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("body"),
       py::arg("debugPrefix") = std::string())
  .def("lpnormalization",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          int64_t p,
          const std::string &name) -> TensorId{
           return opset.lpnormalization(args,
                                        axis,
                                        p,
                                        name);
       },
       py::arg("args"),
       py::arg("axis") = -1,
       py::arg("p") = 2,
       py::arg("debugPrefix") = std::string())
  .def("lppool",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& kernel_shape,
          int64_t p,
          const std::vector<int64_t>& pads,
          const std::vector<int64_t>& strides,
          const std::string &name) -> TensorId{
           return opset.lppool(args,
                               kernel_shape,
                               p,
                               pads,
                               strides,
                               name);
       },
       py::arg("args"),
       py::arg("kernel_shape"),
       py::arg("p") = 2,
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("matmul",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.matmul(args,
                               name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("max",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.max(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("maxpool",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& kernel_shape,
          const std::vector<int64_t>& pads,
          const std::vector<int64_t>& strides,
          const std::string &name) -> TensorId{
           return opset.maxpool(args,
                                kernel_shape,
                                pads,
                                strides,
                                name);
       },
       py::arg("args"),
       py::arg("kernel_shape"),
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("maxroipool",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& pooled_shape,
          float spatial_scale,
          const std::string &name) -> TensorId{
           return opset.maxroipool(args,
                                   pooled_shape,
                                   spatial_scale,
                                   name);
       },
       py::arg("args"),
       py::arg("pooled_shape"),
       py::arg("spatial_scale") = 1.0f,
       py::arg("debugPrefix") = std::string())
  .def("mean",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.mean(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("min",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.min(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("mul",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.mul(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("multinomial",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          int64_t dtype,
          int64_t sample_size,
          nonstd::optional<float> seed,
          const std::string &name) -> TensorId{
           return opset.multinomial(args,
                                    dtype,
                                    sample_size,
                                    seed,
                                    name);
       },
       py::arg("args"),
       py::arg("dtype") = 6,
       py::arg("sample_size") = 1,
       py::arg("seed") = nonstd::optional<float>(),
       py::arg("debugPrefix") = std::string())
  .def("neg",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.neg(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("logical_not",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.logical_not(args,
                                    name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("logical_or",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.logical_or(args,
                                   name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("prelu",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.prelu(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("pad",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& pads,
          const std::string& mode,
          float value,
          const std::string &name) -> TensorId{
           return opset.pad(args,
                            pads,
                            mode,
                            value,
                            name);
       },
       py::arg("args"),
       py::arg("pads"),
       py::arg("mode") = "constant",
       py::arg("value") = 0.0f,
       py::arg("debugPrefix") = std::string())
  .def("pow",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.pow(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("rnn",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const std::vector<float>& activation_alpha,
          const std::vector<float>& activation_beta,
          const std::vector<std::string>& activations,
          nonstd::optional<float> clip,
          const std::string& direction,
          nonstd::optional<int64_t> hidden_size,
          const std::string &name) -> std::vector<TensorId>{
           return opset.rnn(args,
                            num_outputs,
                            activation_alpha,
                            activation_beta,
                            activations,
                            clip,
                            direction,
                            hidden_size,
                            name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("activation_alpha") = std::vector<float>(),
       py::arg("activation_beta") = std::vector<float>(),
       py::arg("activations") = std::vector<std::string>(),
       py::arg("clip") = nonstd::optional<float>(),
       py::arg("direction") = "forward",
       py::arg("hidden_size") = nonstd::optional<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("randomnormal",
       [](AiOnnxOpset7 &opset,
          const std::vector<int64_t>& shape,
          int64_t dtype,
          float mean,
          float scale,
          nonstd::optional<float> seed,
          const std::string &name) -> TensorId{
           return opset.randomnormal(                                     shape,
                                     dtype,
                                     mean,
                                     scale,
                                     seed,
                                     name);
       },
       py::arg("shape"),
       py::arg("dtype") = 1,
       py::arg("mean") = 0.0f,
       py::arg("scale") = 1.0f,
       py::arg("seed") = nonstd::optional<float>(),
       py::arg("debugPrefix") = std::string())
  .def("randomnormallike",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<int64_t> dtype,
          float mean,
          float scale,
          nonstd::optional<float> seed,
          const std::string &name) -> TensorId{
           return opset.randomnormallike(args,
                                         dtype,
                                         mean,
                                         scale,
                                         seed,
                                         name);
       },
       py::arg("args"),
       py::arg("dtype") = nonstd::optional<int64_t>(),
       py::arg("mean") = 0.0f,
       py::arg("scale") = 1.0f,
       py::arg("seed") = nonstd::optional<float>(),
       py::arg("debugPrefix") = std::string())
  .def("randomuniform",
       [](AiOnnxOpset7 &opset,
          const std::vector<int64_t>& shape,
          int64_t dtype,
          float high,
          float low,
          nonstd::optional<float> seed,
          const std::string &name) -> TensorId{
           return opset.randomuniform(                                      shape,
                                      dtype,
                                      high,
                                      low,
                                      seed,
                                      name);
       },
       py::arg("shape"),
       py::arg("dtype") = 1,
       py::arg("high") = 1.0f,
       py::arg("low") = 0.0f,
       py::arg("seed") = nonstd::optional<float>(),
       py::arg("debugPrefix") = std::string())
  .def("randomuniformlike",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<int64_t> dtype,
          float high,
          float low,
          nonstd::optional<float> seed,
          const std::string &name) -> TensorId{
           return opset.randomuniformlike(args,
                                          dtype,
                                          high,
                                          low,
                                          seed,
                                          name);
       },
       py::arg("args"),
       py::arg("dtype") = nonstd::optional<int64_t>(),
       py::arg("high") = 1.0f,
       py::arg("low") = 0.0f,
       py::arg("seed") = nonstd::optional<float>(),
       py::arg("debugPrefix") = std::string())
  .def("reciprocal",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.reciprocal(args,
                                   name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("reducel1",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducel1(args,
                                 axes,
                                 keepdims,
                                 name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducel2",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducel2(args,
                                 axes,
                                 keepdims,
                                 name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducelogsum",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducelogsum(args,
                                     axes,
                                     keepdims,
                                     name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducelogsumexp",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducelogsumexp(args,
                                        axes,
                                        keepdims,
                                        name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducemax",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducemax(args,
                                  axes,
                                  keepdims,
                                  name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducemean",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducemean(args,
                                   axes,
                                   keepdims,
                                   name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducemin",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducemin(args,
                                  axes,
                                  keepdims,
                                  name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reduceprod",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reduceprod(args,
                                   axes,
                                   keepdims,
                                   name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducesum",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducesum(args,
                                  axes,
                                  keepdims,
                                  name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducesumsquare",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducesumsquare(args,
                                        axes,
                                        keepdims,
                                        name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("relu",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.relu(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("reshape",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.reshape(args,
                                name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("selu",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          float alpha,
          float gamma,
          const std::string &name) -> TensorId{
           return opset.selu(args,
                             alpha,
                             gamma,
                             name);
       },
       py::arg("args"),
       py::arg("alpha") = 1.67326f,
       py::arg("gamma") = 1.0507f,
       py::arg("debugPrefix") = std::string())
  .def("shape",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.shape(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("sigmoid",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sigmoid(args,
                                name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("sin",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sin(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("size",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.size(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("slice",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& ends,
          const std::vector<int64_t>& starts,
          const std::vector<int64_t>& axes,
          const std::string &name) -> TensorId{
           return opset.slice(args,
                              ends,
                              starts,
                              axes,
                              name);
       },
       py::arg("args"),
       py::arg("ends"),
       py::arg("starts"),
       py::arg("axes") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("softmax",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.softmax(args,
                                axis,
                                name);
       },
       py::arg("args"),
       py::arg("axis") = 1,
       py::arg("debugPrefix") = std::string())
  .def("softplus",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.softplus(args,
                                 name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("softsign",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.softsign(args,
                                 name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("spacetodepth",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          int64_t blocksize,
          const std::string &name) -> TensorId{
           return opset.spacetodepth(args,
                                     blocksize,
                                     name);
       },
       py::arg("args"),
       py::arg("blocksize"),
       py::arg("debugPrefix") = std::string())
  .def("split",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          int64_t axis,
          const std::vector<int64_t>& split,
          const std::string &name) -> std::vector<TensorId>{
           return opset.split(args,
                              num_outputs,
                              axis,
                              split,
                              name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("axis") = 0,
       py::arg("split") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("sqrt",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sqrt(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("squeeze",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& axes,
          const std::string &name) -> TensorId{
           return opset.squeeze(args,
                                axes,
                                name);
       },
       py::arg("args"),
       py::arg("axes") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("sub",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sub(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("sum",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sum(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("tan",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.tan(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("tanh",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.tanh(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("tile",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.tile(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("topk",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          int64_t k,
          int64_t axis,
          const std::string &name) -> std::vector<TensorId>{
           return opset.topk(args,
                             k,
                             axis,
                             name);
       },
       py::arg("args"),
       py::arg("k"),
       py::arg("axis") = -1,
       py::arg("debugPrefix") = std::string())
  .def("transpose",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& perm,
          const std::string &name) -> TensorId{
           return opset.transpose(args,
                                  perm,
                                  name);
       },
       py::arg("args"),
       py::arg("perm") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("unsqueeze",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& axes,
          const std::string &name) -> TensorId{
           return opset.unsqueeze(args,
                                  axes,
                                  name);
       },
       py::arg("args"),
       py::arg("axes"),
       py::arg("debugPrefix") = std::string())
  .def("upsample",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::vector<float>& scales,
          const std::string& mode,
          const std::string &name) -> TensorId{
           return opset.upsample(args,
                                 scales,
                                 mode,
                                 name);
       },
       py::arg("args"),
       py::arg("scales"),
       py::arg("mode") = "nearest",
       py::arg("debugPrefix") = std::string())
  .def("logical_xor",
       [](AiOnnxOpset7 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.logical_xor(args,
                                    name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
;
py::class_<AiOnnxOpset8>(m, "AiOnnxOpset8")
  .def("abs",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.abs(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("acos",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.acos(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("add",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.add(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("logical_and",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.logical_and(args,
                                    name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("argmax",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.argmax(args,
                               axis,
                               keepdims,
                               name);
       },
       py::arg("args"),
       py::arg("axis") = 0,
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("argmin",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.argmin(args,
                               axis,
                               keepdims,
                               name);
       },
       py::arg("args"),
       py::arg("axis") = 0,
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("asin",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.asin(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("atan",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.atan(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("averagepool",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& kernel_shape,
          int64_t count_include_pad,
          const std::vector<int64_t>& pads,
          const std::vector<int64_t>& strides,
          const std::string &name) -> TensorId{
           return opset.averagepool(args,
                                    kernel_shape,
                                    count_include_pad,
                                    pads,
                                    strides,
                                    name);
       },
       py::arg("args"),
       py::arg("kernel_shape"),
       py::arg("count_include_pad") = 0,
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("batchnormalization",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          float epsilon,
          float momentum,
          int64_t spatial,
          const std::string &name) -> std::vector<TensorId>{
           return opset.batchnormalization(args,
                                           num_outputs,
                                           epsilon,
                                           momentum,
                                           spatial,
                                           name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("epsilon") = 1e-05f,
       py::arg("momentum") = 0.9f,
       py::arg("spatial") = 1,
       py::arg("debugPrefix") = std::string())
  .def("cast",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string& to,
          const std::string &name) -> TensorId{
           return opset.cast(args,
                             to,
                             name);
       },
       py::arg("args"),
       py::arg("to"),
       py::arg("debugPrefix") = std::string())
  .def("ceil",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.ceil(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("clip",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          float max,
          float min,
          const std::string &name) -> TensorId{
           return opset.clip(args,
                             max,
                             min,
                             name);
       },
       py::arg("args"),
       py::arg("max") = 3.4028234663852886e+38f,
       py::arg("min") = -3.4028234663852886e+38f,
       py::arg("debugPrefix") = std::string())
  .def("concat",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.concat(args,
                               axis,
                               name);
       },
       py::arg("args"),
       py::arg("axis"),
       py::arg("debugPrefix") = std::string())
  .def("constant",
       [](AiOnnxOpset8 &opset, py::array array, const std::string& name) {
          array = makeContiguous(array);
          ConstVoidData initData;
          initData.data = array.request().ptr;
          initData.info = getTensorInfo(array);
          return opset.constant(initData, name);
        },
       py::arg("value"),
       py::arg("debugPrefix") = std::string())
  .def("conv",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& dilations,
          int64_t group,
          const std::vector<int64_t>& kernel_shape,
          const std::vector<int64_t>& pads,
          const std::vector<int64_t>& strides,
          const std::string &name) -> TensorId{
           return opset.conv(args,
                             dilations,
                             group,
                             kernel_shape,
                             pads,
                             strides,
                             name);
       },
       py::arg("args"),
       py::arg("dilations") = std::vector<int64_t>(),
       py::arg("group") = 1,
       py::arg("kernel_shape") = std::vector<int64_t>(),
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("convtranspose",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& dilations,
          int64_t group,
          const std::vector<int64_t>& kernel_shape,
          const std::vector<int64_t>& output_padding,
          const std::vector<int64_t>& output_shape,
          const std::vector<int64_t>& pads,
          const std::vector<int64_t>& strides,
          const std::string &name) -> TensorId{
           return opset.convtranspose(args,
                                      dilations,
                                      group,
                                      kernel_shape,
                                      output_padding,
                                      output_shape,
                                      pads,
                                      strides,
                                      name);
       },
       py::arg("args"),
       py::arg("dilations") = std::vector<int64_t>(),
       py::arg("group") = 1,
       py::arg("kernel_shape") = std::vector<int64_t>(),
       py::arg("output_padding") = std::vector<int64_t>(),
       py::arg("output_shape") = std::vector<int64_t>(),
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("cos",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.cos(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("depthtospace",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          int64_t blocksize,
          const std::string &name) -> TensorId{
           return opset.depthtospace(args,
                                     blocksize,
                                     name);
       },
       py::arg("args"),
       py::arg("blocksize"),
       py::arg("debugPrefix") = std::string())
  .def("div",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.div(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("dropout",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          float ratio,
          const std::string &name) -> std::vector<TensorId>{
           return opset.dropout(args,
                                num_outputs,
                                ratio,
                                name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("ratio") = 0.5f,
       py::arg("debugPrefix") = std::string())
  .def("elu",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          float alpha,
          const std::string &name) -> TensorId{
           return opset.elu(args,
                            alpha,
                            name);
       },
       py::arg("args"),
       py::arg("alpha") = 1.0f,
       py::arg("debugPrefix") = std::string())
  .def("equal",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.equal(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("exp",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.exp(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("expand",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.expand(args,
                               name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("flatten",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.flatten(args,
                                axis,
                                name);
       },
       py::arg("args"),
       py::arg("axis") = 1,
       py::arg("debugPrefix") = std::string())
  .def("floor",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.floor(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("gru",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const std::vector<float>& activation_alpha,
          const std::vector<float>& activation_beta,
          const std::vector<std::string>& activations,
          nonstd::optional<float> clip,
          const std::string& direction,
          nonstd::optional<int64_t> hidden_size,
          int64_t linear_before_reset,
          const std::string &name) -> std::vector<TensorId>{
           return opset.gru(args,
                            num_outputs,
                            activation_alpha,
                            activation_beta,
                            activations,
                            clip,
                            direction,
                            hidden_size,
                            linear_before_reset,
                            name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("activation_alpha") = std::vector<float>(),
       py::arg("activation_beta") = std::vector<float>(),
       py::arg("activations") = std::vector<std::string>(),
       py::arg("clip") = nonstd::optional<float>(),
       py::arg("direction") = "forward",
       py::arg("hidden_size") = nonstd::optional<int64_t>(),
       py::arg("linear_before_reset") = 0,
       py::arg("debugPrefix") = std::string())
  .def("gather",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.gather(args,
                               axis,
                               name);
       },
       py::arg("args"),
       py::arg("axis") = 0,
       py::arg("debugPrefix") = std::string())
  .def("gemm",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          float alpha,
          float beta,
          int64_t transA,
          int64_t transB,
          const std::string &name) -> TensorId{
           return opset.gemm(args,
                             alpha,
                             beta,
                             transA,
                             transB,
                             name);
       },
       py::arg("args"),
       py::arg("alpha") = 1.0f,
       py::arg("beta") = 1.0f,
       py::arg("transA") = 0,
       py::arg("transB") = 0,
       py::arg("debugPrefix") = std::string())
  .def("globalaveragepool",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.globalaveragepool(args,
                                          name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("globallppool",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          int64_t p,
          const std::string &name) -> TensorId{
           return opset.globallppool(args,
                                     p,
                                     name);
       },
       py::arg("args"),
       py::arg("p") = 2,
       py::arg("debugPrefix") = std::string())
  .def("globalmaxpool",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.globalmaxpool(args,
                                      name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("greater",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.greater(args,
                                name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("hardsigmoid",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          float alpha,
          float beta,
          const std::string &name) -> TensorId{
           return opset.hardsigmoid(args,
                                    alpha,
                                    beta,
                                    name);
       },
       py::arg("args"),
       py::arg("alpha") = 0.2f,
       py::arg("beta") = 0.5f,
       py::arg("debugPrefix") = std::string())
  .def("hardmax",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.hardmax(args,
                                axis,
                                name);
       },
       py::arg("args"),
       py::arg("axis") = 1,
       py::arg("debugPrefix") = std::string())
  .def("identity",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.identity(args,
                                 name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("logical_if",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const Builder& else_branch,
          const Builder& then_branch,
          const std::string &name) -> std::vector<TensorId>{
           return opset.logical_if(args,
                                   num_outputs,
                                   else_branch,
                                   then_branch,
                                   name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("else_branch"),
       py::arg("then_branch"),
       py::arg("debugPrefix") = std::string())
  .def("instancenormalization",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          float epsilon,
          const std::string &name) -> TensorId{
           return opset.instancenormalization(args,
                                              epsilon,
                                              name);
       },
       py::arg("args"),
       py::arg("epsilon") = 1e-05f,
       py::arg("debugPrefix") = std::string())
  .def("lrn",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          int64_t size,
          float alpha,
          float beta,
          float bias,
          const std::string &name) -> TensorId{
           return opset.lrn(args,
                            size,
                            alpha,
                            beta,
                            bias,
                            name);
       },
       py::arg("args"),
       py::arg("size"),
       py::arg("alpha") = 0.0001f,
       py::arg("beta") = 0.75f,
       py::arg("bias") = 1.0f,
       py::arg("debugPrefix") = std::string())
  .def("lstm",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const std::vector<float>& activation_alpha,
          const std::vector<float>& activation_beta,
          const std::vector<std::string>& activations,
          nonstd::optional<float> clip,
          const std::string& direction,
          nonstd::optional<int64_t> hidden_size,
          int64_t input_forget,
          const std::string &name) -> std::vector<TensorId>{
           return opset.lstm(args,
                             num_outputs,
                             activation_alpha,
                             activation_beta,
                             activations,
                             clip,
                             direction,
                             hidden_size,
                             input_forget,
                             name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("activation_alpha") = std::vector<float>(),
       py::arg("activation_beta") = std::vector<float>(),
       py::arg("activations") = std::vector<std::string>(),
       py::arg("clip") = nonstd::optional<float>(),
       py::arg("direction") = "forward",
       py::arg("hidden_size") = nonstd::optional<int64_t>(),
       py::arg("input_forget") = 0,
       py::arg("debugPrefix") = std::string())
  .def("leakyrelu",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          float alpha,
          const std::string &name) -> TensorId{
           return opset.leakyrelu(args,
                                  alpha,
                                  name);
       },
       py::arg("args"),
       py::arg("alpha") = 0.01f,
       py::arg("debugPrefix") = std::string())
  .def("less",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.less(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("log",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.log(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("logsoftmax",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.logsoftmax(args,
                                   axis,
                                   name);
       },
       py::arg("args"),
       py::arg("axis") = 1,
       py::arg("debugPrefix") = std::string())
  .def("loop",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const Builder& body,
          const std::string &name) -> std::vector<TensorId>{
           return opset.loop(args,
                             num_outputs,
                             body,
                             name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("body"),
       py::arg("debugPrefix") = std::string())
  .def("lpnormalization",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          int64_t p,
          const std::string &name) -> TensorId{
           return opset.lpnormalization(args,
                                        axis,
                                        p,
                                        name);
       },
       py::arg("args"),
       py::arg("axis") = -1,
       py::arg("p") = 2,
       py::arg("debugPrefix") = std::string())
  .def("lppool",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& kernel_shape,
          int64_t p,
          const std::vector<int64_t>& pads,
          const std::vector<int64_t>& strides,
          const std::string &name) -> TensorId{
           return opset.lppool(args,
                               kernel_shape,
                               p,
                               pads,
                               strides,
                               name);
       },
       py::arg("args"),
       py::arg("kernel_shape"),
       py::arg("p") = 2,
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("matmul",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.matmul(args,
                               name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("max",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.max(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("maxpool",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const std::vector<int64_t>& kernel_shape,
          const std::vector<int64_t>& pads,
          int64_t storage_order,
          const std::vector<int64_t>& strides,
          const std::string &name) -> std::vector<TensorId>{
           return opset.maxpool(args,
                                num_outputs,
                                kernel_shape,
                                pads,
                                storage_order,
                                strides,
                                name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("kernel_shape"),
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("storage_order") = 0,
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("maxroipool",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& pooled_shape,
          float spatial_scale,
          const std::string &name) -> TensorId{
           return opset.maxroipool(args,
                                   pooled_shape,
                                   spatial_scale,
                                   name);
       },
       py::arg("args"),
       py::arg("pooled_shape"),
       py::arg("spatial_scale") = 1.0f,
       py::arg("debugPrefix") = std::string())
  .def("mean",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.mean(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("min",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.min(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("mul",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.mul(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("multinomial",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          int64_t dtype,
          int64_t sample_size,
          nonstd::optional<float> seed,
          const std::string &name) -> TensorId{
           return opset.multinomial(args,
                                    dtype,
                                    sample_size,
                                    seed,
                                    name);
       },
       py::arg("args"),
       py::arg("dtype") = 6,
       py::arg("sample_size") = 1,
       py::arg("seed") = nonstd::optional<float>(),
       py::arg("debugPrefix") = std::string())
  .def("neg",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.neg(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("logical_not",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.logical_not(args,
                                    name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("logical_or",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.logical_or(args,
                                   name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("prelu",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.prelu(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("pad",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& pads,
          const std::string& mode,
          float value,
          const std::string &name) -> TensorId{
           return opset.pad(args,
                            pads,
                            mode,
                            value,
                            name);
       },
       py::arg("args"),
       py::arg("pads"),
       py::arg("mode") = "constant",
       py::arg("value") = 0.0f,
       py::arg("debugPrefix") = std::string())
  .def("pow",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.pow(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("rnn",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const std::vector<float>& activation_alpha,
          const std::vector<float>& activation_beta,
          const std::vector<std::string>& activations,
          nonstd::optional<float> clip,
          const std::string& direction,
          nonstd::optional<int64_t> hidden_size,
          const std::string &name) -> std::vector<TensorId>{
           return opset.rnn(args,
                            num_outputs,
                            activation_alpha,
                            activation_beta,
                            activations,
                            clip,
                            direction,
                            hidden_size,
                            name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("activation_alpha") = std::vector<float>(),
       py::arg("activation_beta") = std::vector<float>(),
       py::arg("activations") = std::vector<std::string>(),
       py::arg("clip") = nonstd::optional<float>(),
       py::arg("direction") = "forward",
       py::arg("hidden_size") = nonstd::optional<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("randomnormal",
       [](AiOnnxOpset8 &opset,
          const std::vector<int64_t>& shape,
          int64_t dtype,
          float mean,
          float scale,
          nonstd::optional<float> seed,
          const std::string &name) -> TensorId{
           return opset.randomnormal(                                     shape,
                                     dtype,
                                     mean,
                                     scale,
                                     seed,
                                     name);
       },
       py::arg("shape"),
       py::arg("dtype") = 1,
       py::arg("mean") = 0.0f,
       py::arg("scale") = 1.0f,
       py::arg("seed") = nonstd::optional<float>(),
       py::arg("debugPrefix") = std::string())
  .def("randomnormallike",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<int64_t> dtype,
          float mean,
          float scale,
          nonstd::optional<float> seed,
          const std::string &name) -> TensorId{
           return opset.randomnormallike(args,
                                         dtype,
                                         mean,
                                         scale,
                                         seed,
                                         name);
       },
       py::arg("args"),
       py::arg("dtype") = nonstd::optional<int64_t>(),
       py::arg("mean") = 0.0f,
       py::arg("scale") = 1.0f,
       py::arg("seed") = nonstd::optional<float>(),
       py::arg("debugPrefix") = std::string())
  .def("randomuniform",
       [](AiOnnxOpset8 &opset,
          const std::vector<int64_t>& shape,
          int64_t dtype,
          float high,
          float low,
          nonstd::optional<float> seed,
          const std::string &name) -> TensorId{
           return opset.randomuniform(                                      shape,
                                      dtype,
                                      high,
                                      low,
                                      seed,
                                      name);
       },
       py::arg("shape"),
       py::arg("dtype") = 1,
       py::arg("high") = 1.0f,
       py::arg("low") = 0.0f,
       py::arg("seed") = nonstd::optional<float>(),
       py::arg("debugPrefix") = std::string())
  .def("randomuniformlike",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<int64_t> dtype,
          float high,
          float low,
          nonstd::optional<float> seed,
          const std::string &name) -> TensorId{
           return opset.randomuniformlike(args,
                                          dtype,
                                          high,
                                          low,
                                          seed,
                                          name);
       },
       py::arg("args"),
       py::arg("dtype") = nonstd::optional<int64_t>(),
       py::arg("high") = 1.0f,
       py::arg("low") = 0.0f,
       py::arg("seed") = nonstd::optional<float>(),
       py::arg("debugPrefix") = std::string())
  .def("reciprocal",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.reciprocal(args,
                                   name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("reducel1",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducel1(args,
                                 axes,
                                 keepdims,
                                 name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducel2",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducel2(args,
                                 axes,
                                 keepdims,
                                 name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducelogsum",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducelogsum(args,
                                     axes,
                                     keepdims,
                                     name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducelogsumexp",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducelogsumexp(args,
                                        axes,
                                        keepdims,
                                        name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducemax",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducemax(args,
                                  axes,
                                  keepdims,
                                  name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducemean",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducemean(args,
                                   axes,
                                   keepdims,
                                   name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducemin",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducemin(args,
                                  axes,
                                  keepdims,
                                  name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reduceprod",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reduceprod(args,
                                   axes,
                                   keepdims,
                                   name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducesum",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducesum(args,
                                  axes,
                                  keepdims,
                                  name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducesumsquare",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducesumsquare(args,
                                        axes,
                                        keepdims,
                                        name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("relu",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.relu(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("reshape",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.reshape(args,
                                name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("scan",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const Builder& body,
          int64_t num_scan_inputs,
          const std::vector<int64_t>& directions,
          const std::string &name) -> std::vector<TensorId>{
           return opset.scan(args,
                             num_outputs,
                             body,
                             num_scan_inputs,
                             directions,
                             name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("body"),
       py::arg("num_scan_inputs"),
       py::arg("directions") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("selu",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          float alpha,
          float gamma,
          const std::string &name) -> TensorId{
           return opset.selu(args,
                             alpha,
                             gamma,
                             name);
       },
       py::arg("args"),
       py::arg("alpha") = 1.67326f,
       py::arg("gamma") = 1.0507f,
       py::arg("debugPrefix") = std::string())
  .def("shape",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.shape(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("sigmoid",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sigmoid(args,
                                name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("sin",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sin(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("size",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.size(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("slice",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& ends,
          const std::vector<int64_t>& starts,
          const std::vector<int64_t>& axes,
          const std::string &name) -> TensorId{
           return opset.slice(args,
                              ends,
                              starts,
                              axes,
                              name);
       },
       py::arg("args"),
       py::arg("ends"),
       py::arg("starts"),
       py::arg("axes") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("softmax",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.softmax(args,
                                axis,
                                name);
       },
       py::arg("args"),
       py::arg("axis") = 1,
       py::arg("debugPrefix") = std::string())
  .def("softplus",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.softplus(args,
                                 name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("softsign",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.softsign(args,
                                 name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("spacetodepth",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          int64_t blocksize,
          const std::string &name) -> TensorId{
           return opset.spacetodepth(args,
                                     blocksize,
                                     name);
       },
       py::arg("args"),
       py::arg("blocksize"),
       py::arg("debugPrefix") = std::string())
  .def("split",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          int64_t axis,
          const std::vector<int64_t>& split,
          const std::string &name) -> std::vector<TensorId>{
           return opset.split(args,
                              num_outputs,
                              axis,
                              split,
                              name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("axis") = 0,
       py::arg("split") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("sqrt",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sqrt(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("squeeze",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& axes,
          const std::string &name) -> TensorId{
           return opset.squeeze(args,
                                axes,
                                name);
       },
       py::arg("args"),
       py::arg("axes") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("sub",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sub(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("sum",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sum(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("tan",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.tan(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("tanh",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.tanh(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("tile",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.tile(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("topk",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          int64_t k,
          int64_t axis,
          const std::string &name) -> std::vector<TensorId>{
           return opset.topk(args,
                             k,
                             axis,
                             name);
       },
       py::arg("args"),
       py::arg("k"),
       py::arg("axis") = -1,
       py::arg("debugPrefix") = std::string())
  .def("transpose",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& perm,
          const std::string &name) -> TensorId{
           return opset.transpose(args,
                                  perm,
                                  name);
       },
       py::arg("args"),
       py::arg("perm") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("unsqueeze",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& axes,
          const std::string &name) -> TensorId{
           return opset.unsqueeze(args,
                                  axes,
                                  name);
       },
       py::arg("args"),
       py::arg("axes"),
       py::arg("debugPrefix") = std::string())
  .def("upsample",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::vector<float>& scales,
          const std::string& mode,
          const std::string &name) -> TensorId{
           return opset.upsample(args,
                                 scales,
                                 mode,
                                 name);
       },
       py::arg("args"),
       py::arg("scales"),
       py::arg("mode") = "nearest",
       py::arg("debugPrefix") = std::string())
  .def("logical_xor",
       [](AiOnnxOpset8 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.logical_xor(args,
                                    name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
;
py::class_<AiOnnxOpset9>(m, "AiOnnxOpset9")
  .def("abs",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.abs(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("acos",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.acos(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("acosh",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.acosh(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("add",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.add(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("logical_and",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.logical_and(args,
                                    name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("argmax",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.argmax(args,
                               axis,
                               keepdims,
                               name);
       },
       py::arg("args"),
       py::arg("axis") = 0,
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("argmin",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.argmin(args,
                               axis,
                               keepdims,
                               name);
       },
       py::arg("args"),
       py::arg("axis") = 0,
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("asin",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.asin(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("asinh",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.asinh(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("atan",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.atan(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("atanh",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.atanh(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("averagepool",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& kernel_shape,
          int64_t count_include_pad,
          const std::vector<int64_t>& pads,
          const std::vector<int64_t>& strides,
          const std::string &name) -> TensorId{
           return opset.averagepool(args,
                                    kernel_shape,
                                    count_include_pad,
                                    pads,
                                    strides,
                                    name);
       },
       py::arg("args"),
       py::arg("kernel_shape"),
       py::arg("count_include_pad") = 0,
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("batchnormalization",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          float epsilon,
          float momentum,
          const std::string &name) -> std::vector<TensorId>{
           return opset.batchnormalization(args,
                                           num_outputs,
                                           epsilon,
                                           momentum,
                                           name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("epsilon") = 1e-05f,
       py::arg("momentum") = 0.9f,
       py::arg("debugPrefix") = std::string())
  .def("cast",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string& to,
          const std::string &name) -> TensorId{
           return opset.cast(args,
                             to,
                             name);
       },
       py::arg("args"),
       py::arg("to"),
       py::arg("debugPrefix") = std::string())
  .def("ceil",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.ceil(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("clip",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          float max,
          float min,
          const std::string &name) -> TensorId{
           return opset.clip(args,
                             max,
                             min,
                             name);
       },
       py::arg("args"),
       py::arg("max") = 3.4028234663852886e+38f,
       py::arg("min") = -3.4028234663852886e+38f,
       py::arg("debugPrefix") = std::string())
  .def("compress",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<int64_t> axis,
          const std::string &name) -> TensorId{
           return opset.compress(args,
                                 axis,
                                 name);
       },
       py::arg("args"),
       py::arg("axis") = nonstd::optional<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("concat",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.concat(args,
                               axis,
                               name);
       },
       py::arg("args"),
       py::arg("axis"),
       py::arg("debugPrefix") = std::string())
  .def("constant",
       [](AiOnnxOpset9 &opset, py::array array, const std::string& name) {
          array = makeContiguous(array);
          ConstVoidData initData;
          initData.data = array.request().ptr;
          initData.info = getTensorInfo(array);
          return opset.constant(initData, name);
        },
       py::arg("value"),
       py::arg("debugPrefix") = std::string())
  .def("constantofshape",
      [](AiOnnxOpset9 &opset,                           const std::vector<TensorId> &args,                           py::array array,                           const std::string &name) {                            ConstVoidData initData;                            initData.data = array.request().ptr;                            initData.info = getTensorInfo(array);                            return opset.constantofshape(args, initData, name);                        },       py::arg("args"),
       py::arg("value"),
       py::arg("debugPrefix") = std::string())
  .def("conv",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& dilations,
          int64_t group,
          const std::vector<int64_t>& kernel_shape,
          const std::vector<int64_t>& pads,
          const std::vector<int64_t>& strides,
          const std::string &name) -> TensorId{
           return opset.conv(args,
                             dilations,
                             group,
                             kernel_shape,
                             pads,
                             strides,
                             name);
       },
       py::arg("args"),
       py::arg("dilations") = std::vector<int64_t>(),
       py::arg("group") = 1,
       py::arg("kernel_shape") = std::vector<int64_t>(),
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("convtranspose",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& dilations,
          int64_t group,
          const std::vector<int64_t>& kernel_shape,
          const std::vector<int64_t>& output_padding,
          const std::vector<int64_t>& output_shape,
          const std::vector<int64_t>& pads,
          const std::vector<int64_t>& strides,
          const std::string &name) -> TensorId{
           return opset.convtranspose(args,
                                      dilations,
                                      group,
                                      kernel_shape,
                                      output_padding,
                                      output_shape,
                                      pads,
                                      strides,
                                      name);
       },
       py::arg("args"),
       py::arg("dilations") = std::vector<int64_t>(),
       py::arg("group") = 1,
       py::arg("kernel_shape") = std::vector<int64_t>(),
       py::arg("output_padding") = std::vector<int64_t>(),
       py::arg("output_shape") = std::vector<int64_t>(),
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("cos",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.cos(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("cosh",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.cosh(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("depthtospace",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          int64_t blocksize,
          const std::string &name) -> TensorId{
           return opset.depthtospace(args,
                                     blocksize,
                                     name);
       },
       py::arg("args"),
       py::arg("blocksize"),
       py::arg("debugPrefix") = std::string())
  .def("div",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.div(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("dropout",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          float ratio,
          const std::string &name) -> std::vector<TensorId>{
           return opset.dropout(args,
                                num_outputs,
                                ratio,
                                name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("ratio") = 0.5f,
       py::arg("debugPrefix") = std::string())
  .def("elu",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          float alpha,
          const std::string &name) -> TensorId{
           return opset.elu(args,
                            alpha,
                            name);
       },
       py::arg("args"),
       py::arg("alpha") = 1.0f,
       py::arg("debugPrefix") = std::string())
  .def("equal",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.equal(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("erf",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.erf(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("exp",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.exp(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("expand",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.expand(args,
                               name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("eyelike",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<int64_t> dtype,
          int64_t k,
          const std::string &name) -> TensorId{
           return opset.eyelike(args,
                                dtype,
                                k,
                                name);
       },
       py::arg("args"),
       py::arg("dtype") = nonstd::optional<int64_t>(),
       py::arg("k") = 0,
       py::arg("debugPrefix") = std::string())
  .def("flatten",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.flatten(args,
                                axis,
                                name);
       },
       py::arg("args"),
       py::arg("axis") = 1,
       py::arg("debugPrefix") = std::string())
  .def("floor",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.floor(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("gru",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const std::vector<float>& activation_alpha,
          const std::vector<float>& activation_beta,
          const std::vector<std::string>& activations,
          nonstd::optional<float> clip,
          const std::string& direction,
          nonstd::optional<int64_t> hidden_size,
          int64_t linear_before_reset,
          const std::string &name) -> std::vector<TensorId>{
           return opset.gru(args,
                            num_outputs,
                            activation_alpha,
                            activation_beta,
                            activations,
                            clip,
                            direction,
                            hidden_size,
                            linear_before_reset,
                            name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("activation_alpha") = std::vector<float>(),
       py::arg("activation_beta") = std::vector<float>(),
       py::arg("activations") = std::vector<std::string>(),
       py::arg("clip") = nonstd::optional<float>(),
       py::arg("direction") = "forward",
       py::arg("hidden_size") = nonstd::optional<int64_t>(),
       py::arg("linear_before_reset") = 0,
       py::arg("debugPrefix") = std::string())
  .def("gather",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.gather(args,
                               axis,
                               name);
       },
       py::arg("args"),
       py::arg("axis") = 0,
       py::arg("debugPrefix") = std::string())
  .def("gemm",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          float alpha,
          float beta,
          int64_t transA,
          int64_t transB,
          const std::string &name) -> TensorId{
           return opset.gemm(args,
                             alpha,
                             beta,
                             transA,
                             transB,
                             name);
       },
       py::arg("args"),
       py::arg("alpha") = 1.0f,
       py::arg("beta") = 1.0f,
       py::arg("transA") = 0,
       py::arg("transB") = 0,
       py::arg("debugPrefix") = std::string())
  .def("globalaveragepool",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.globalaveragepool(args,
                                          name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("globallppool",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          int64_t p,
          const std::string &name) -> TensorId{
           return opset.globallppool(args,
                                     p,
                                     name);
       },
       py::arg("args"),
       py::arg("p") = 2,
       py::arg("debugPrefix") = std::string())
  .def("globalmaxpool",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.globalmaxpool(args,
                                      name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("greater",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.greater(args,
                                name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("hardsigmoid",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          float alpha,
          float beta,
          const std::string &name) -> TensorId{
           return opset.hardsigmoid(args,
                                    alpha,
                                    beta,
                                    name);
       },
       py::arg("args"),
       py::arg("alpha") = 0.2f,
       py::arg("beta") = 0.5f,
       py::arg("debugPrefix") = std::string())
  .def("hardmax",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.hardmax(args,
                                axis,
                                name);
       },
       py::arg("args"),
       py::arg("axis") = 1,
       py::arg("debugPrefix") = std::string())
  .def("identity",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.identity(args,
                                 name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("logical_if",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const Builder& else_branch,
          const Builder& then_branch,
          const std::string &name) -> std::vector<TensorId>{
           return opset.logical_if(args,
                                   num_outputs,
                                   else_branch,
                                   then_branch,
                                   name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("else_branch"),
       py::arg("then_branch"),
       py::arg("debugPrefix") = std::string())
  .def("instancenormalization",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          float epsilon,
          const std::string &name) -> TensorId{
           return opset.instancenormalization(args,
                                              epsilon,
                                              name);
       },
       py::arg("args"),
       py::arg("epsilon") = 1e-05f,
       py::arg("debugPrefix") = std::string())
  .def("isnan",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.isnan(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("lrn",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          int64_t size,
          float alpha,
          float beta,
          float bias,
          const std::string &name) -> TensorId{
           return opset.lrn(args,
                            size,
                            alpha,
                            beta,
                            bias,
                            name);
       },
       py::arg("args"),
       py::arg("size"),
       py::arg("alpha") = 0.0001f,
       py::arg("beta") = 0.75f,
       py::arg("bias") = 1.0f,
       py::arg("debugPrefix") = std::string())
  .def("lstm",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const std::vector<float>& activation_alpha,
          const std::vector<float>& activation_beta,
          const std::vector<std::string>& activations,
          nonstd::optional<float> clip,
          const std::string& direction,
          nonstd::optional<int64_t> hidden_size,
          int64_t input_forget,
          const std::string &name) -> std::vector<TensorId>{
           return opset.lstm(args,
                             num_outputs,
                             activation_alpha,
                             activation_beta,
                             activations,
                             clip,
                             direction,
                             hidden_size,
                             input_forget,
                             name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("activation_alpha") = std::vector<float>(),
       py::arg("activation_beta") = std::vector<float>(),
       py::arg("activations") = std::vector<std::string>(),
       py::arg("clip") = nonstd::optional<float>(),
       py::arg("direction") = "forward",
       py::arg("hidden_size") = nonstd::optional<int64_t>(),
       py::arg("input_forget") = 0,
       py::arg("debugPrefix") = std::string())
  .def("leakyrelu",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          float alpha,
          const std::string &name) -> TensorId{
           return opset.leakyrelu(args,
                                  alpha,
                                  name);
       },
       py::arg("args"),
       py::arg("alpha") = 0.01f,
       py::arg("debugPrefix") = std::string())
  .def("less",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.less(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("log",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.log(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("logsoftmax",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.logsoftmax(args,
                                   axis,
                                   name);
       },
       py::arg("args"),
       py::arg("axis") = 1,
       py::arg("debugPrefix") = std::string())
  .def("loop",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const Builder& body,
          const std::string &name) -> std::vector<TensorId>{
           return opset.loop(args,
                             num_outputs,
                             body,
                             name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("body"),
       py::arg("debugPrefix") = std::string())
  .def("lpnormalization",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          int64_t p,
          const std::string &name) -> TensorId{
           return opset.lpnormalization(args,
                                        axis,
                                        p,
                                        name);
       },
       py::arg("args"),
       py::arg("axis") = -1,
       py::arg("p") = 2,
       py::arg("debugPrefix") = std::string())
  .def("lppool",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& kernel_shape,
          int64_t p,
          const std::vector<int64_t>& pads,
          const std::vector<int64_t>& strides,
          const std::string &name) -> TensorId{
           return opset.lppool(args,
                               kernel_shape,
                               p,
                               pads,
                               strides,
                               name);
       },
       py::arg("args"),
       py::arg("kernel_shape"),
       py::arg("p") = 2,
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("matmul",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.matmul(args,
                               name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("max",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.max(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("maxpool",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const std::vector<int64_t>& kernel_shape,
          const std::vector<int64_t>& pads,
          int64_t storage_order,
          const std::vector<int64_t>& strides,
          const std::string &name) -> std::vector<TensorId>{
           return opset.maxpool(args,
                                num_outputs,
                                kernel_shape,
                                pads,
                                storage_order,
                                strides,
                                name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("kernel_shape"),
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("storage_order") = 0,
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("maxroipool",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& pooled_shape,
          float spatial_scale,
          const std::string &name) -> TensorId{
           return opset.maxroipool(args,
                                   pooled_shape,
                                   spatial_scale,
                                   name);
       },
       py::arg("args"),
       py::arg("pooled_shape"),
       py::arg("spatial_scale") = 1.0f,
       py::arg("debugPrefix") = std::string())
  .def("maxunpool",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& kernel_shape,
          const std::vector<int64_t>& pads,
          const std::vector<int64_t>& strides,
          const std::string &name) -> TensorId{
           return opset.maxunpool(args,
                                  kernel_shape,
                                  pads,
                                  strides,
                                  name);
       },
       py::arg("args"),
       py::arg("kernel_shape"),
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("mean",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.mean(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("meanvariancenormalization",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& axes,
          const std::string &name) -> TensorId{
           return opset.meanvariancenormalization(args,
                                                  axes,
                                                  name);
       },
       py::arg("args"),
       py::arg("axes") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("min",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.min(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("mul",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.mul(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("multinomial",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          int64_t dtype,
          int64_t sample_size,
          nonstd::optional<float> seed,
          const std::string &name) -> TensorId{
           return opset.multinomial(args,
                                    dtype,
                                    sample_size,
                                    seed,
                                    name);
       },
       py::arg("args"),
       py::arg("dtype") = 6,
       py::arg("sample_size") = 1,
       py::arg("seed") = nonstd::optional<float>(),
       py::arg("debugPrefix") = std::string())
  .def("neg",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.neg(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("nonzero",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.nonzero(args,
                                name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("logical_not",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.logical_not(args,
                                    name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("onehot",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.onehot(args,
                               axis,
                               name);
       },
       py::arg("args"),
       py::arg("axis") = -1,
       py::arg("debugPrefix") = std::string())
  .def("logical_or",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.logical_or(args,
                                   name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("prelu",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.prelu(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("pad",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& pads,
          const std::string& mode,
          float value,
          const std::string &name) -> TensorId{
           return opset.pad(args,
                            pads,
                            mode,
                            value,
                            name);
       },
       py::arg("args"),
       py::arg("pads"),
       py::arg("mode") = "constant",
       py::arg("value") = 0.0f,
       py::arg("debugPrefix") = std::string())
  .def("pow",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.pow(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("rnn",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const std::vector<float>& activation_alpha,
          const std::vector<float>& activation_beta,
          const std::vector<std::string>& activations,
          nonstd::optional<float> clip,
          const std::string& direction,
          nonstd::optional<int64_t> hidden_size,
          const std::string &name) -> std::vector<TensorId>{
           return opset.rnn(args,
                            num_outputs,
                            activation_alpha,
                            activation_beta,
                            activations,
                            clip,
                            direction,
                            hidden_size,
                            name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("activation_alpha") = std::vector<float>(),
       py::arg("activation_beta") = std::vector<float>(),
       py::arg("activations") = std::vector<std::string>(),
       py::arg("clip") = nonstd::optional<float>(),
       py::arg("direction") = "forward",
       py::arg("hidden_size") = nonstd::optional<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("randomnormal",
       [](AiOnnxOpset9 &opset,
          const std::vector<int64_t>& shape,
          int64_t dtype,
          float mean,
          float scale,
          nonstd::optional<float> seed,
          const std::string &name) -> TensorId{
           return opset.randomnormal(                                     shape,
                                     dtype,
                                     mean,
                                     scale,
                                     seed,
                                     name);
       },
       py::arg("shape"),
       py::arg("dtype") = 1,
       py::arg("mean") = 0.0f,
       py::arg("scale") = 1.0f,
       py::arg("seed") = nonstd::optional<float>(),
       py::arg("debugPrefix") = std::string())
  .def("randomnormallike",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<int64_t> dtype,
          float mean,
          float scale,
          nonstd::optional<float> seed,
          const std::string &name) -> TensorId{
           return opset.randomnormallike(args,
                                         dtype,
                                         mean,
                                         scale,
                                         seed,
                                         name);
       },
       py::arg("args"),
       py::arg("dtype") = nonstd::optional<int64_t>(),
       py::arg("mean") = 0.0f,
       py::arg("scale") = 1.0f,
       py::arg("seed") = nonstd::optional<float>(),
       py::arg("debugPrefix") = std::string())
  .def("randomuniform",
       [](AiOnnxOpset9 &opset,
          const std::vector<int64_t>& shape,
          int64_t dtype,
          float high,
          float low,
          nonstd::optional<float> seed,
          const std::string &name) -> TensorId{
           return opset.randomuniform(                                      shape,
                                      dtype,
                                      high,
                                      low,
                                      seed,
                                      name);
       },
       py::arg("shape"),
       py::arg("dtype") = 1,
       py::arg("high") = 1.0f,
       py::arg("low") = 0.0f,
       py::arg("seed") = nonstd::optional<float>(),
       py::arg("debugPrefix") = std::string())
  .def("randomuniformlike",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<int64_t> dtype,
          float high,
          float low,
          nonstd::optional<float> seed,
          const std::string &name) -> TensorId{
           return opset.randomuniformlike(args,
                                          dtype,
                                          high,
                                          low,
                                          seed,
                                          name);
       },
       py::arg("args"),
       py::arg("dtype") = nonstd::optional<int64_t>(),
       py::arg("high") = 1.0f,
       py::arg("low") = 0.0f,
       py::arg("seed") = nonstd::optional<float>(),
       py::arg("debugPrefix") = std::string())
  .def("reciprocal",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.reciprocal(args,
                                   name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("reducel1",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducel1(args,
                                 axes,
                                 keepdims,
                                 name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducel2",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducel2(args,
                                 axes,
                                 keepdims,
                                 name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducelogsum",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducelogsum(args,
                                     axes,
                                     keepdims,
                                     name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducelogsumexp",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducelogsumexp(args,
                                        axes,
                                        keepdims,
                                        name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducemax",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducemax(args,
                                  axes,
                                  keepdims,
                                  name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducemean",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducemean(args,
                                   axes,
                                   keepdims,
                                   name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducemin",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducemin(args,
                                  axes,
                                  keepdims,
                                  name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reduceprod",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reduceprod(args,
                                   axes,
                                   keepdims,
                                   name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducesum",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducesum(args,
                                  axes,
                                  keepdims,
                                  name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducesumsquare",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducesumsquare(args,
                                        axes,
                                        keepdims,
                                        name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("relu",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.relu(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("reshape",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.reshape(args,
                                name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("scan",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const Builder& body,
          int64_t num_scan_inputs,
          const std::vector<int64_t>& scan_input_axes,
          const std::vector<int64_t>& scan_input_directions,
          const std::vector<int64_t>& scan_output_axes,
          const std::vector<int64_t>& scan_output_directions,
          const std::string &name) -> std::vector<TensorId>{
           return opset.scan(args,
                             num_outputs,
                             body,
                             num_scan_inputs,
                             scan_input_axes,
                             scan_input_directions,
                             scan_output_axes,
                             scan_output_directions,
                             name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("body"),
       py::arg("num_scan_inputs"),
       py::arg("scan_input_axes") = std::vector<int64_t>(),
       py::arg("scan_input_directions") = std::vector<int64_t>(),
       py::arg("scan_output_axes") = std::vector<int64_t>(),
       py::arg("scan_output_directions") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("scatter",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.scatter(args,
                                axis,
                                name);
       },
       py::arg("args"),
       py::arg("axis") = 0,
       py::arg("debugPrefix") = std::string())
  .def("selu",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          float alpha,
          float gamma,
          const std::string &name) -> TensorId{
           return opset.selu(args,
                             alpha,
                             gamma,
                             name);
       },
       py::arg("args"),
       py::arg("alpha") = 1.67326f,
       py::arg("gamma") = 1.0507f,
       py::arg("debugPrefix") = std::string())
  .def("shape",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.shape(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("shrink",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          float bias,
          float lambd,
          const std::string &name) -> TensorId{
           return opset.shrink(args,
                               bias,
                               lambd,
                               name);
       },
       py::arg("args"),
       py::arg("bias") = 0.0f,
       py::arg("lambd") = 0.5f,
       py::arg("debugPrefix") = std::string())
  .def("sigmoid",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sigmoid(args,
                                name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("sign",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sign(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("sin",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sin(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("sinh",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sinh(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("size",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.size(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("slice",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& ends,
          const std::vector<int64_t>& starts,
          const std::vector<int64_t>& axes,
          const std::string &name) -> TensorId{
           return opset.slice(args,
                              ends,
                              starts,
                              axes,
                              name);
       },
       py::arg("args"),
       py::arg("ends"),
       py::arg("starts"),
       py::arg("axes") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("softmax",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.softmax(args,
                                axis,
                                name);
       },
       py::arg("args"),
       py::arg("axis") = 1,
       py::arg("debugPrefix") = std::string())
  .def("softplus",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.softplus(args,
                                 name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("softsign",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.softsign(args,
                                 name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("spacetodepth",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          int64_t blocksize,
          const std::string &name) -> TensorId{
           return opset.spacetodepth(args,
                                     blocksize,
                                     name);
       },
       py::arg("args"),
       py::arg("blocksize"),
       py::arg("debugPrefix") = std::string())
  .def("split",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          int64_t axis,
          const std::vector<int64_t>& split,
          const std::string &name) -> std::vector<TensorId>{
           return opset.split(args,
                              num_outputs,
                              axis,
                              split,
                              name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("axis") = 0,
       py::arg("split") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("sqrt",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sqrt(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("squeeze",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& axes,
          const std::string &name) -> TensorId{
           return opset.squeeze(args,
                                axes,
                                name);
       },
       py::arg("args"),
       py::arg("axes") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("sub",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sub(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("sum",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sum(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("tan",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.tan(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("tanh",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.tanh(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("tfidfvectorizer",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          int64_t max_gram_length,
          int64_t max_skip_count,
          int64_t min_gram_length,
          const std::string& mode,
          const std::vector<int64_t>& ngram_counts,
          const std::vector<int64_t>& ngram_indexes,
          const std::vector<int64_t>& pool_int64s,
          const std::vector<std::string>& pool_strings,
          const std::vector<float>& weights,
          const std::string &name) -> TensorId{
           return opset.tfidfvectorizer(args,
                                        max_gram_length,
                                        max_skip_count,
                                        min_gram_length,
                                        mode,
                                        ngram_counts,
                                        ngram_indexes,
                                        pool_int64s,
                                        pool_strings,
                                        weights,
                                        name);
       },
       py::arg("args"),
       py::arg("max_gram_length"),
       py::arg("max_skip_count"),
       py::arg("min_gram_length"),
       py::arg("mode"),
       py::arg("ngram_counts"),
       py::arg("ngram_indexes"),
       py::arg("pool_int64s") = std::vector<int64_t>(),
       py::arg("pool_strings") = std::vector<std::string>(),
       py::arg("weights") = std::vector<float>(),
       py::arg("debugPrefix") = std::string())
  .def("tile",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.tile(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("topk",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          int64_t k,
          int64_t axis,
          const std::string &name) -> std::vector<TensorId>{
           return opset.topk(args,
                             k,
                             axis,
                             name);
       },
       py::arg("args"),
       py::arg("k"),
       py::arg("axis") = -1,
       py::arg("debugPrefix") = std::string())
  .def("transpose",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& perm,
          const std::string &name) -> TensorId{
           return opset.transpose(args,
                                  perm,
                                  name);
       },
       py::arg("args"),
       py::arg("perm") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("unsqueeze",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& axes,
          const std::string &name) -> TensorId{
           return opset.unsqueeze(args,
                                  axes,
                                  name);
       },
       py::arg("args"),
       py::arg("axes"),
       py::arg("debugPrefix") = std::string())
  .def("upsample",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string& mode,
          const std::string &name) -> TensorId{
           return opset.upsample(args,
                                 mode,
                                 name);
       },
       py::arg("args"),
       py::arg("mode") = "nearest",
       py::arg("debugPrefix") = std::string())
  .def("where",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.where(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("logical_xor",
       [](AiOnnxOpset9 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.logical_xor(args,
                                    name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
;
py::class_<AiOnnxOpset10>(m, "AiOnnxOpset10")
  .def("abs",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.abs(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("acos",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.acos(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("acosh",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.acosh(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("add",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.add(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("logical_and",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.logical_and(args,
                                    name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("argmax",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.argmax(args,
                               axis,
                               keepdims,
                               name);
       },
       py::arg("args"),
       py::arg("axis") = 0,
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("argmin",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.argmin(args,
                               axis,
                               keepdims,
                               name);
       },
       py::arg("args"),
       py::arg("axis") = 0,
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("asin",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.asin(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("asinh",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.asinh(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("atan",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.atan(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("atanh",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.atanh(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("averagepool",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& kernel_shape,
          int64_t ceil_mode,
          int64_t count_include_pad,
          const std::vector<int64_t>& pads,
          const std::vector<int64_t>& strides,
          const std::string &name) -> TensorId{
           return opset.averagepool(args,
                                    kernel_shape,
                                    ceil_mode,
                                    count_include_pad,
                                    pads,
                                    strides,
                                    name);
       },
       py::arg("args"),
       py::arg("kernel_shape"),
       py::arg("ceil_mode") = 0,
       py::arg("count_include_pad") = 0,
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("batchnormalization",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          float epsilon,
          float momentum,
          const std::string &name) -> std::vector<TensorId>{
           return opset.batchnormalization(args,
                                           num_outputs,
                                           epsilon,
                                           momentum,
                                           name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("epsilon") = 1e-05f,
       py::arg("momentum") = 0.9f,
       py::arg("debugPrefix") = std::string())
  .def("cast",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string& to,
          const std::string &name) -> TensorId{
           return opset.cast(args,
                             to,
                             name);
       },
       py::arg("args"),
       py::arg("to"),
       py::arg("debugPrefix") = std::string())
  .def("ceil",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.ceil(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("clip",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          float max,
          float min,
          const std::string &name) -> TensorId{
           return opset.clip(args,
                             max,
                             min,
                             name);
       },
       py::arg("args"),
       py::arg("max") = 3.4028234663852886e+38f,
       py::arg("min") = -3.4028234663852886e+38f,
       py::arg("debugPrefix") = std::string())
  .def("compress",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<int64_t> axis,
          const std::string &name) -> TensorId{
           return opset.compress(args,
                                 axis,
                                 name);
       },
       py::arg("args"),
       py::arg("axis") = nonstd::optional<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("concat",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.concat(args,
                               axis,
                               name);
       },
       py::arg("args"),
       py::arg("axis"),
       py::arg("debugPrefix") = std::string())
  .def("constant",
       [](AiOnnxOpset10 &opset, py::array array, const std::string& name) {
          array = makeContiguous(array);
          ConstVoidData initData;
          initData.data = array.request().ptr;
          initData.info = getTensorInfo(array);
          return opset.constant(initData, name);
        },
       py::arg("value"),
       py::arg("debugPrefix") = std::string())
  .def("constantofshape",
      [](AiOnnxOpset10 &opset,                           const std::vector<TensorId> &args,                           py::array array,                           const std::string &name) {                            ConstVoidData initData;                            initData.data = array.request().ptr;                            initData.info = getTensorInfo(array);                            return opset.constantofshape(args, initData, name);                        },       py::arg("args"),
       py::arg("value"),
       py::arg("debugPrefix") = std::string())
  .def("conv",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& dilations,
          int64_t group,
          const std::vector<int64_t>& kernel_shape,
          const std::vector<int64_t>& pads,
          const std::vector<int64_t>& strides,
          const std::string &name) -> TensorId{
           return opset.conv(args,
                             dilations,
                             group,
                             kernel_shape,
                             pads,
                             strides,
                             name);
       },
       py::arg("args"),
       py::arg("dilations") = std::vector<int64_t>(),
       py::arg("group") = 1,
       py::arg("kernel_shape") = std::vector<int64_t>(),
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("convinteger",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& dilations,
          int64_t group,
          const std::vector<int64_t>& kernel_shape,
          const std::vector<int64_t>& pads,
          const std::vector<int64_t>& strides,
          const std::string &name) -> TensorId{
           return opset.convinteger(args,
                                    dilations,
                                    group,
                                    kernel_shape,
                                    pads,
                                    strides,
                                    name);
       },
       py::arg("args"),
       py::arg("dilations") = std::vector<int64_t>(),
       py::arg("group") = 1,
       py::arg("kernel_shape") = std::vector<int64_t>(),
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("convtranspose",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& dilations,
          int64_t group,
          const std::vector<int64_t>& kernel_shape,
          const std::vector<int64_t>& output_padding,
          const std::vector<int64_t>& output_shape,
          const std::vector<int64_t>& pads,
          const std::vector<int64_t>& strides,
          const std::string &name) -> TensorId{
           return opset.convtranspose(args,
                                      dilations,
                                      group,
                                      kernel_shape,
                                      output_padding,
                                      output_shape,
                                      pads,
                                      strides,
                                      name);
       },
       py::arg("args"),
       py::arg("dilations") = std::vector<int64_t>(),
       py::arg("group") = 1,
       py::arg("kernel_shape") = std::vector<int64_t>(),
       py::arg("output_padding") = std::vector<int64_t>(),
       py::arg("output_shape") = std::vector<int64_t>(),
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("cos",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.cos(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("cosh",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.cosh(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("depthtospace",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          int64_t blocksize,
          const std::string &name) -> TensorId{
           return opset.depthtospace(args,
                                     blocksize,
                                     name);
       },
       py::arg("args"),
       py::arg("blocksize"),
       py::arg("debugPrefix") = std::string())
  .def("dequantizelinear",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.dequantizelinear(args,
                                         name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("div",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.div(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("dropout",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          float ratio,
          const std::string &name) -> std::vector<TensorId>{
           return opset.dropout(args,
                                num_outputs,
                                ratio,
                                name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("ratio") = 0.5f,
       py::arg("debugPrefix") = std::string())
  .def("elu",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          float alpha,
          const std::string &name) -> TensorId{
           return opset.elu(args,
                            alpha,
                            name);
       },
       py::arg("args"),
       py::arg("alpha") = 1.0f,
       py::arg("debugPrefix") = std::string())
  .def("equal",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.equal(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("erf",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.erf(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("exp",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.exp(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("expand",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.expand(args,
                               name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("eyelike",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<int64_t> dtype,
          int64_t k,
          const std::string &name) -> TensorId{
           return opset.eyelike(args,
                                dtype,
                                k,
                                name);
       },
       py::arg("args"),
       py::arg("dtype") = nonstd::optional<int64_t>(),
       py::arg("k") = 0,
       py::arg("debugPrefix") = std::string())
  .def("flatten",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.flatten(args,
                                axis,
                                name);
       },
       py::arg("args"),
       py::arg("axis") = 1,
       py::arg("debugPrefix") = std::string())
  .def("floor",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.floor(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("gru",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const std::vector<float>& activation_alpha,
          const std::vector<float>& activation_beta,
          const std::vector<std::string>& activations,
          nonstd::optional<float> clip,
          const std::string& direction,
          nonstd::optional<int64_t> hidden_size,
          int64_t linear_before_reset,
          const std::string &name) -> std::vector<TensorId>{
           return opset.gru(args,
                            num_outputs,
                            activation_alpha,
                            activation_beta,
                            activations,
                            clip,
                            direction,
                            hidden_size,
                            linear_before_reset,
                            name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("activation_alpha") = std::vector<float>(),
       py::arg("activation_beta") = std::vector<float>(),
       py::arg("activations") = std::vector<std::string>(),
       py::arg("clip") = nonstd::optional<float>(),
       py::arg("direction") = "forward",
       py::arg("hidden_size") = nonstd::optional<int64_t>(),
       py::arg("linear_before_reset") = 0,
       py::arg("debugPrefix") = std::string())
  .def("gather",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.gather(args,
                               axis,
                               name);
       },
       py::arg("args"),
       py::arg("axis") = 0,
       py::arg("debugPrefix") = std::string())
  .def("gemm",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          float alpha,
          float beta,
          int64_t transA,
          int64_t transB,
          const std::string &name) -> TensorId{
           return opset.gemm(args,
                             alpha,
                             beta,
                             transA,
                             transB,
                             name);
       },
       py::arg("args"),
       py::arg("alpha") = 1.0f,
       py::arg("beta") = 1.0f,
       py::arg("transA") = 0,
       py::arg("transB") = 0,
       py::arg("debugPrefix") = std::string())
  .def("globalaveragepool",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.globalaveragepool(args,
                                          name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("globallppool",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          int64_t p,
          const std::string &name) -> TensorId{
           return opset.globallppool(args,
                                     p,
                                     name);
       },
       py::arg("args"),
       py::arg("p") = 2,
       py::arg("debugPrefix") = std::string())
  .def("globalmaxpool",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.globalmaxpool(args,
                                      name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("greater",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.greater(args,
                                name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("hardsigmoid",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          float alpha,
          float beta,
          const std::string &name) -> TensorId{
           return opset.hardsigmoid(args,
                                    alpha,
                                    beta,
                                    name);
       },
       py::arg("args"),
       py::arg("alpha") = 0.2f,
       py::arg("beta") = 0.5f,
       py::arg("debugPrefix") = std::string())
  .def("hardmax",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.hardmax(args,
                                axis,
                                name);
       },
       py::arg("args"),
       py::arg("axis") = 1,
       py::arg("debugPrefix") = std::string())
  .def("identity",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.identity(args,
                                 name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("logical_if",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const Builder& else_branch,
          const Builder& then_branch,
          const std::string &name) -> std::vector<TensorId>{
           return opset.logical_if(args,
                                   num_outputs,
                                   else_branch,
                                   then_branch,
                                   name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("else_branch"),
       py::arg("then_branch"),
       py::arg("debugPrefix") = std::string())
  .def("instancenormalization",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          float epsilon,
          const std::string &name) -> TensorId{
           return opset.instancenormalization(args,
                                              epsilon,
                                              name);
       },
       py::arg("args"),
       py::arg("epsilon") = 1e-05f,
       py::arg("debugPrefix") = std::string())
  .def("isinf",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          int64_t detect_negative,
          int64_t detect_positive,
          const std::string &name) -> TensorId{
           return opset.isinf(args,
                              detect_negative,
                              detect_positive,
                              name);
       },
       py::arg("args"),
       py::arg("detect_negative") = 1,
       py::arg("detect_positive") = 1,
       py::arg("debugPrefix") = std::string())
  .def("isnan",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.isnan(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("lrn",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          int64_t size,
          float alpha,
          float beta,
          float bias,
          const std::string &name) -> TensorId{
           return opset.lrn(args,
                            size,
                            alpha,
                            beta,
                            bias,
                            name);
       },
       py::arg("args"),
       py::arg("size"),
       py::arg("alpha") = 0.0001f,
       py::arg("beta") = 0.75f,
       py::arg("bias") = 1.0f,
       py::arg("debugPrefix") = std::string())
  .def("lstm",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const std::vector<float>& activation_alpha,
          const std::vector<float>& activation_beta,
          const std::vector<std::string>& activations,
          nonstd::optional<float> clip,
          const std::string& direction,
          nonstd::optional<int64_t> hidden_size,
          int64_t input_forget,
          const std::string &name) -> std::vector<TensorId>{
           return opset.lstm(args,
                             num_outputs,
                             activation_alpha,
                             activation_beta,
                             activations,
                             clip,
                             direction,
                             hidden_size,
                             input_forget,
                             name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("activation_alpha") = std::vector<float>(),
       py::arg("activation_beta") = std::vector<float>(),
       py::arg("activations") = std::vector<std::string>(),
       py::arg("clip") = nonstd::optional<float>(),
       py::arg("direction") = "forward",
       py::arg("hidden_size") = nonstd::optional<int64_t>(),
       py::arg("input_forget") = 0,
       py::arg("debugPrefix") = std::string())
  .def("leakyrelu",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          float alpha,
          const std::string &name) -> TensorId{
           return opset.leakyrelu(args,
                                  alpha,
                                  name);
       },
       py::arg("args"),
       py::arg("alpha") = 0.01f,
       py::arg("debugPrefix") = std::string())
  .def("less",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.less(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("log",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.log(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("logsoftmax",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.logsoftmax(args,
                                   axis,
                                   name);
       },
       py::arg("args"),
       py::arg("axis") = 1,
       py::arg("debugPrefix") = std::string())
  .def("loop",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const Builder& body,
          const std::string &name) -> std::vector<TensorId>{
           return opset.loop(args,
                             num_outputs,
                             body,
                             name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("body"),
       py::arg("debugPrefix") = std::string())
  .def("lpnormalization",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          int64_t p,
          const std::string &name) -> TensorId{
           return opset.lpnormalization(args,
                                        axis,
                                        p,
                                        name);
       },
       py::arg("args"),
       py::arg("axis") = -1,
       py::arg("p") = 2,
       py::arg("debugPrefix") = std::string())
  .def("lppool",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& kernel_shape,
          int64_t p,
          const std::vector<int64_t>& pads,
          const std::vector<int64_t>& strides,
          const std::string &name) -> TensorId{
           return opset.lppool(args,
                               kernel_shape,
                               p,
                               pads,
                               strides,
                               name);
       },
       py::arg("args"),
       py::arg("kernel_shape"),
       py::arg("p") = 2,
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("matmul",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.matmul(args,
                               name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("matmulinteger",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.matmulinteger(args,
                                      name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("max",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.max(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("maxpool",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const std::vector<int64_t>& kernel_shape,
          int64_t ceil_mode,
          const std::vector<int64_t>& dilations,
          const std::vector<int64_t>& pads,
          int64_t storage_order,
          const std::vector<int64_t>& strides,
          const std::string &name) -> std::vector<TensorId>{
           return opset.maxpool(args,
                                num_outputs,
                                kernel_shape,
                                ceil_mode,
                                dilations,
                                pads,
                                storage_order,
                                strides,
                                name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("kernel_shape"),
       py::arg("ceil_mode") = 0,
       py::arg("dilations") = std::vector<int64_t>(),
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("storage_order") = 0,
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("maxroipool",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& pooled_shape,
          float spatial_scale,
          const std::string &name) -> TensorId{
           return opset.maxroipool(args,
                                   pooled_shape,
                                   spatial_scale,
                                   name);
       },
       py::arg("args"),
       py::arg("pooled_shape"),
       py::arg("spatial_scale") = 1.0f,
       py::arg("debugPrefix") = std::string())
  .def("maxunpool",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& kernel_shape,
          const std::vector<int64_t>& pads,
          const std::vector<int64_t>& strides,
          const std::string &name) -> TensorId{
           return opset.maxunpool(args,
                                  kernel_shape,
                                  pads,
                                  strides,
                                  name);
       },
       py::arg("args"),
       py::arg("kernel_shape"),
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("mean",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.mean(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("meanvariancenormalization",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& axes,
          const std::string &name) -> TensorId{
           return opset.meanvariancenormalization(args,
                                                  axes,
                                                  name);
       },
       py::arg("args"),
       py::arg("axes") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("min",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.min(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("mod",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          int64_t fmod,
          const std::string &name) -> TensorId{
           return opset.mod(args,
                            fmod,
                            name);
       },
       py::arg("args"),
       py::arg("fmod") = 0,
       py::arg("debugPrefix") = std::string())
  .def("mul",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.mul(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("multinomial",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          int64_t dtype,
          int64_t sample_size,
          nonstd::optional<float> seed,
          const std::string &name) -> TensorId{
           return opset.multinomial(args,
                                    dtype,
                                    sample_size,
                                    seed,
                                    name);
       },
       py::arg("args"),
       py::arg("dtype") = 6,
       py::arg("sample_size") = 1,
       py::arg("seed") = nonstd::optional<float>(),
       py::arg("debugPrefix") = std::string())
  .def("neg",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.neg(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("nonmaxsuppression",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          int64_t center_point_box,
          const std::string &name) -> TensorId{
           return opset.nonmaxsuppression(args,
                                          center_point_box,
                                          name);
       },
       py::arg("args"),
       py::arg("center_point_box") = 0,
       py::arg("debugPrefix") = std::string())
  .def("nonzero",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.nonzero(args,
                                name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("logical_not",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.logical_not(args,
                                    name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("onehot",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.onehot(args,
                               axis,
                               name);
       },
       py::arg("args"),
       py::arg("axis") = -1,
       py::arg("debugPrefix") = std::string())
  .def("logical_or",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.logical_or(args,
                                   name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("prelu",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.prelu(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("pad",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& pads,
          const std::string& mode,
          float value,
          const std::string &name) -> TensorId{
           return opset.pad(args,
                            pads,
                            mode,
                            value,
                            name);
       },
       py::arg("args"),
       py::arg("pads"),
       py::arg("mode") = "constant",
       py::arg("value") = 0.0f,
       py::arg("debugPrefix") = std::string())
  .def("pow",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.pow(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("qlinearconv",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& dilations,
          int64_t group,
          const std::vector<int64_t>& kernel_shape,
          const std::vector<int64_t>& pads,
          const std::vector<int64_t>& strides,
          const std::string &name) -> TensorId{
           return opset.qlinearconv(args,
                                    dilations,
                                    group,
                                    kernel_shape,
                                    pads,
                                    strides,
                                    name);
       },
       py::arg("args"),
       py::arg("dilations") = std::vector<int64_t>(),
       py::arg("group") = 1,
       py::arg("kernel_shape") = std::vector<int64_t>(),
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("qlinearmatmul",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.qlinearmatmul(args,
                                      name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("quantizelinear",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.quantizelinear(args,
                                       name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("rnn",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const std::vector<float>& activation_alpha,
          const std::vector<float>& activation_beta,
          const std::vector<std::string>& activations,
          nonstd::optional<float> clip,
          const std::string& direction,
          nonstd::optional<int64_t> hidden_size,
          const std::string &name) -> std::vector<TensorId>{
           return opset.rnn(args,
                            num_outputs,
                            activation_alpha,
                            activation_beta,
                            activations,
                            clip,
                            direction,
                            hidden_size,
                            name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("activation_alpha") = std::vector<float>(),
       py::arg("activation_beta") = std::vector<float>(),
       py::arg("activations") = std::vector<std::string>(),
       py::arg("clip") = nonstd::optional<float>(),
       py::arg("direction") = "forward",
       py::arg("hidden_size") = nonstd::optional<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("randomnormal",
       [](AiOnnxOpset10 &opset,
          const std::vector<int64_t>& shape,
          int64_t dtype,
          float mean,
          float scale,
          nonstd::optional<float> seed,
          const std::string &name) -> TensorId{
           return opset.randomnormal(                                     shape,
                                     dtype,
                                     mean,
                                     scale,
                                     seed,
                                     name);
       },
       py::arg("shape"),
       py::arg("dtype") = 1,
       py::arg("mean") = 0.0f,
       py::arg("scale") = 1.0f,
       py::arg("seed") = nonstd::optional<float>(),
       py::arg("debugPrefix") = std::string())
  .def("randomnormallike",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<int64_t> dtype,
          float mean,
          float scale,
          nonstd::optional<float> seed,
          const std::string &name) -> TensorId{
           return opset.randomnormallike(args,
                                         dtype,
                                         mean,
                                         scale,
                                         seed,
                                         name);
       },
       py::arg("args"),
       py::arg("dtype") = nonstd::optional<int64_t>(),
       py::arg("mean") = 0.0f,
       py::arg("scale") = 1.0f,
       py::arg("seed") = nonstd::optional<float>(),
       py::arg("debugPrefix") = std::string())
  .def("randomuniform",
       [](AiOnnxOpset10 &opset,
          const std::vector<int64_t>& shape,
          int64_t dtype,
          float high,
          float low,
          nonstd::optional<float> seed,
          const std::string &name) -> TensorId{
           return opset.randomuniform(                                      shape,
                                      dtype,
                                      high,
                                      low,
                                      seed,
                                      name);
       },
       py::arg("shape"),
       py::arg("dtype") = 1,
       py::arg("high") = 1.0f,
       py::arg("low") = 0.0f,
       py::arg("seed") = nonstd::optional<float>(),
       py::arg("debugPrefix") = std::string())
  .def("randomuniformlike",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<int64_t> dtype,
          float high,
          float low,
          nonstd::optional<float> seed,
          const std::string &name) -> TensorId{
           return opset.randomuniformlike(args,
                                          dtype,
                                          high,
                                          low,
                                          seed,
                                          name);
       },
       py::arg("args"),
       py::arg("dtype") = nonstd::optional<int64_t>(),
       py::arg("high") = 1.0f,
       py::arg("low") = 0.0f,
       py::arg("seed") = nonstd::optional<float>(),
       py::arg("debugPrefix") = std::string())
  .def("reciprocal",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.reciprocal(args,
                                   name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("reducel1",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducel1(args,
                                 axes,
                                 keepdims,
                                 name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducel2",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducel2(args,
                                 axes,
                                 keepdims,
                                 name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducelogsum",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducelogsum(args,
                                     axes,
                                     keepdims,
                                     name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducelogsumexp",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducelogsumexp(args,
                                        axes,
                                        keepdims,
                                        name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducemax",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducemax(args,
                                  axes,
                                  keepdims,
                                  name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducemean",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducemean(args,
                                   axes,
                                   keepdims,
                                   name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducemin",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducemin(args,
                                  axes,
                                  keepdims,
                                  name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reduceprod",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reduceprod(args,
                                   axes,
                                   keepdims,
                                   name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducesum",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducesum(args,
                                  axes,
                                  keepdims,
                                  name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducesumsquare",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducesumsquare(args,
                                        axes,
                                        keepdims,
                                        name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("relu",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.relu(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("reshape",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.reshape(args,
                                name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("resize",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string& mode,
          const std::string &name) -> TensorId{
           return opset.resize(args,
                               mode,
                               name);
       },
       py::arg("args"),
       py::arg("mode") = "nearest",
       py::arg("debugPrefix") = std::string())
  .def("reversesequence",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          int64_t batch_axis,
          int64_t time_axis,
          const std::string &name) -> TensorId{
           return opset.reversesequence(args,
                                        batch_axis,
                                        time_axis,
                                        name);
       },
       py::arg("args"),
       py::arg("batch_axis") = 1,
       py::arg("time_axis") = 0,
       py::arg("debugPrefix") = std::string())
  .def("roialign",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string& mode,
          int64_t output_height,
          int64_t output_width,
          int64_t sampling_ratio,
          float spatial_scale,
          const std::string &name) -> TensorId{
           return opset.roialign(args,
                                 mode,
                                 output_height,
                                 output_width,
                                 sampling_ratio,
                                 spatial_scale,
                                 name);
       },
       py::arg("args"),
       py::arg("mode") = "avg",
       py::arg("output_height") = 1,
       py::arg("output_width") = 1,
       py::arg("sampling_ratio") = 0,
       py::arg("spatial_scale") = 1.0f,
       py::arg("debugPrefix") = std::string())
  .def("scan",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const Builder& body,
          int64_t num_scan_inputs,
          const std::vector<int64_t>& scan_input_axes,
          const std::vector<int64_t>& scan_input_directions,
          const std::vector<int64_t>& scan_output_axes,
          const std::vector<int64_t>& scan_output_directions,
          const std::string &name) -> std::vector<TensorId>{
           return opset.scan(args,
                             num_outputs,
                             body,
                             num_scan_inputs,
                             scan_input_axes,
                             scan_input_directions,
                             scan_output_axes,
                             scan_output_directions,
                             name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("body"),
       py::arg("num_scan_inputs"),
       py::arg("scan_input_axes") = std::vector<int64_t>(),
       py::arg("scan_input_directions") = std::vector<int64_t>(),
       py::arg("scan_output_axes") = std::vector<int64_t>(),
       py::arg("scan_output_directions") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("scatter",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.scatter(args,
                                axis,
                                name);
       },
       py::arg("args"),
       py::arg("axis") = 0,
       py::arg("debugPrefix") = std::string())
  .def("selu",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          float alpha,
          float gamma,
          const std::string &name) -> TensorId{
           return opset.selu(args,
                             alpha,
                             gamma,
                             name);
       },
       py::arg("args"),
       py::arg("alpha") = 1.67326f,
       py::arg("gamma") = 1.0507f,
       py::arg("debugPrefix") = std::string())
  .def("shape",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.shape(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("shrink",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          float bias,
          float lambd,
          const std::string &name) -> TensorId{
           return opset.shrink(args,
                               bias,
                               lambd,
                               name);
       },
       py::arg("args"),
       py::arg("bias") = 0.0f,
       py::arg("lambd") = 0.5f,
       py::arg("debugPrefix") = std::string())
  .def("sigmoid",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sigmoid(args,
                                name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("sign",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sign(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("sin",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sin(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("sinh",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sinh(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("size",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.size(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("slice",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.slice(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("softmax",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.softmax(args,
                                axis,
                                name);
       },
       py::arg("args"),
       py::arg("axis") = 1,
       py::arg("debugPrefix") = std::string())
  .def("softplus",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.softplus(args,
                                 name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("softsign",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.softsign(args,
                                 name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("spacetodepth",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          int64_t blocksize,
          const std::string &name) -> TensorId{
           return opset.spacetodepth(args,
                                     blocksize,
                                     name);
       },
       py::arg("args"),
       py::arg("blocksize"),
       py::arg("debugPrefix") = std::string())
  .def("split",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          int64_t axis,
          const std::vector<int64_t>& split,
          const std::string &name) -> std::vector<TensorId>{
           return opset.split(args,
                              num_outputs,
                              axis,
                              split,
                              name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("axis") = 0,
       py::arg("split") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("sqrt",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sqrt(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("squeeze",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& axes,
          const std::string &name) -> TensorId{
           return opset.squeeze(args,
                                axes,
                                name);
       },
       py::arg("args"),
       py::arg("axes") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("stringnormalizer",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string& case_change_action,
          int64_t is_case_sensitive,
          nonstd::optional<std::string> locale,
          const std::vector<std::string>& stopwords,
          const std::string &name) -> TensorId{
           return opset.stringnormalizer(args,
                                         case_change_action,
                                         is_case_sensitive,
                                         locale,
                                         stopwords,
                                         name);
       },
       py::arg("args"),
       py::arg("case_change_action") = "NONE",
       py::arg("is_case_sensitive") = 0,
       py::arg("locale") = std::string(),
       py::arg("stopwords") = std::vector<std::string>(),
       py::arg("debugPrefix") = std::string())
  .def("sub",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sub(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("sum",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sum(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("tan",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.tan(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("tanh",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.tanh(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("tfidfvectorizer",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          int64_t max_gram_length,
          int64_t max_skip_count,
          int64_t min_gram_length,
          const std::string& mode,
          const std::vector<int64_t>& ngram_counts,
          const std::vector<int64_t>& ngram_indexes,
          const std::vector<int64_t>& pool_int64s,
          const std::vector<std::string>& pool_strings,
          const std::vector<float>& weights,
          const std::string &name) -> TensorId{
           return opset.tfidfvectorizer(args,
                                        max_gram_length,
                                        max_skip_count,
                                        min_gram_length,
                                        mode,
                                        ngram_counts,
                                        ngram_indexes,
                                        pool_int64s,
                                        pool_strings,
                                        weights,
                                        name);
       },
       py::arg("args"),
       py::arg("max_gram_length"),
       py::arg("max_skip_count"),
       py::arg("min_gram_length"),
       py::arg("mode"),
       py::arg("ngram_counts"),
       py::arg("ngram_indexes"),
       py::arg("pool_int64s") = std::vector<int64_t>(),
       py::arg("pool_strings") = std::vector<std::string>(),
       py::arg("weights") = std::vector<float>(),
       py::arg("debugPrefix") = std::string())
  .def("thresholdedrelu",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          float alpha,
          const std::string &name) -> TensorId{
           return opset.thresholdedrelu(args,
                                        alpha,
                                        name);
       },
       py::arg("args"),
       py::arg("alpha") = 1.0f,
       py::arg("debugPrefix") = std::string())
  .def("tile",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.tile(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("topk",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> std::vector<TensorId>{
           return opset.topk(args,
                             axis,
                             name);
       },
       py::arg("args"),
       py::arg("axis") = -1,
       py::arg("debugPrefix") = std::string())
  .def("transpose",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& perm,
          const std::string &name) -> TensorId{
           return opset.transpose(args,
                                  perm,
                                  name);
       },
       py::arg("args"),
       py::arg("perm") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("unsqueeze",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& axes,
          const std::string &name) -> TensorId{
           return opset.unsqueeze(args,
                                  axes,
                                  name);
       },
       py::arg("args"),
       py::arg("axes"),
       py::arg("debugPrefix") = std::string())
  .def("upsample",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string& mode,
          const std::string &name) -> TensorId{
           return opset.upsample(args,
                                 mode,
                                 name);
       },
       py::arg("args"),
       py::arg("mode") = "nearest",
       py::arg("debugPrefix") = std::string())
  .def("where",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.where(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("logical_xor",
       [](AiOnnxOpset10 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.logical_xor(args,
                                    name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
;
py::class_<AiOnnxOpset11>(m, "AiOnnxOpset11")
  .def("abs",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.abs(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("acos",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.acos(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("acosh",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.acosh(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("add",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.add(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("logical_and",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.logical_and(args,
                                    name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("argmax",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.argmax(args,
                               axis,
                               keepdims,
                               name);
       },
       py::arg("args"),
       py::arg("axis") = 0,
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("argmin",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.argmin(args,
                               axis,
                               keepdims,
                               name);
       },
       py::arg("args"),
       py::arg("axis") = 0,
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("asin",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.asin(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("asinh",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.asinh(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("atan",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.atan(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("atanh",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.atanh(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("averagepool",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& kernel_shape,
          int64_t ceil_mode,
          int64_t count_include_pad,
          const std::vector<int64_t>& pads,
          const std::vector<int64_t>& strides,
          const std::string &name) -> TensorId{
           return opset.averagepool(args,
                                    kernel_shape,
                                    ceil_mode,
                                    count_include_pad,
                                    pads,
                                    strides,
                                    name);
       },
       py::arg("args"),
       py::arg("kernel_shape"),
       py::arg("ceil_mode") = 0,
       py::arg("count_include_pad") = 0,
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("batchnormalization",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          float epsilon,
          float momentum,
          const std::string &name) -> std::vector<TensorId>{
           return opset.batchnormalization(args,
                                           num_outputs,
                                           epsilon,
                                           momentum,
                                           name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("epsilon") = 1e-05f,
       py::arg("momentum") = 0.9f,
       py::arg("debugPrefix") = std::string())
  .def("bitshift",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string& direction,
          const std::string &name) -> TensorId{
           return opset.bitshift(args,
                                 direction,
                                 name);
       },
       py::arg("args"),
       py::arg("direction"),
       py::arg("debugPrefix") = std::string())
  .def("cast",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string& to,
          const std::string &name) -> TensorId{
           return opset.cast(args,
                             to,
                             name);
       },
       py::arg("args"),
       py::arg("to"),
       py::arg("debugPrefix") = std::string())
  .def("ceil",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.ceil(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("clip",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.clip(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("compress",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<int64_t> axis,
          const std::string &name) -> TensorId{
           return opset.compress(args,
                                 axis,
                                 name);
       },
       py::arg("args"),
       py::arg("axis") = nonstd::optional<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("concat",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.concat(args,
                               axis,
                               name);
       },
       py::arg("args"),
       py::arg("axis"),
       py::arg("debugPrefix") = std::string())
  .def("concatfromsequence",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          int64_t new_axis,
          const std::string &name) -> TensorId{
           return opset.concatfromsequence(args,
                                           axis,
                                           new_axis,
                                           name);
       },
       py::arg("args"),
       py::arg("axis"),
       py::arg("new_axis") = 0,
       py::arg("debugPrefix") = std::string())
  .def("constant",
       [](AiOnnxOpset11 &opset, py::array array, bool is_value_sparse, const std::string& name) {
          array = makeContiguous(array);
          ConstVoidData initData;
          initData.data = array.request().ptr;
          initData.info = getTensorInfo(array);
          return opset.constant(initData, is_value_sparse, name);
       },
       py::arg("value"),
       py::arg("is_value_sparse") = false,
       py::arg("debugPrefix") = std::string())
  .def("constantofshape",
      [](AiOnnxOpset11 &opset,                           const std::vector<TensorId> &args,                           py::array array,                           const std::string &name) {                            ConstVoidData initData;                            initData.data = array.request().ptr;                            initData.info = getTensorInfo(array);                            return opset.constantofshape(args, initData, name);                        },       py::arg("args"),
       py::arg("value"),
       py::arg("debugPrefix") = std::string())
  .def("conv",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& dilations,
          int64_t group,
          const std::vector<int64_t>& kernel_shape,
          const std::vector<int64_t>& pads,
          const std::vector<int64_t>& strides,
          const std::string &name) -> TensorId{
           return opset.conv(args,
                             dilations,
                             group,
                             kernel_shape,
                             pads,
                             strides,
                             name);
       },
       py::arg("args"),
       py::arg("dilations") = std::vector<int64_t>(),
       py::arg("group") = 1,
       py::arg("kernel_shape") = std::vector<int64_t>(),
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("convinteger",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& dilations,
          int64_t group,
          const std::vector<int64_t>& kernel_shape,
          const std::vector<int64_t>& pads,
          const std::vector<int64_t>& strides,
          const std::string &name) -> TensorId{
           return opset.convinteger(args,
                                    dilations,
                                    group,
                                    kernel_shape,
                                    pads,
                                    strides,
                                    name);
       },
       py::arg("args"),
       py::arg("dilations") = std::vector<int64_t>(),
       py::arg("group") = 1,
       py::arg("kernel_shape") = std::vector<int64_t>(),
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("convtranspose",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& dilations,
          int64_t group,
          const std::vector<int64_t>& kernel_shape,
          const std::vector<int64_t>& output_padding,
          const std::vector<int64_t>& output_shape,
          const std::vector<int64_t>& pads,
          const std::vector<int64_t>& strides,
          const std::string &name) -> TensorId{
           return opset.convtranspose(args,
                                      dilations,
                                      group,
                                      kernel_shape,
                                      output_padding,
                                      output_shape,
                                      pads,
                                      strides,
                                      name);
       },
       py::arg("args"),
       py::arg("dilations") = std::vector<int64_t>(),
       py::arg("group") = 1,
       py::arg("kernel_shape") = std::vector<int64_t>(),
       py::arg("output_padding") = std::vector<int64_t>(),
       py::arg("output_shape") = std::vector<int64_t>(),
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("cos",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.cos(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("cosh",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.cosh(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("cumsum",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          int64_t exclusive,
          int64_t reverse,
          const std::string &name) -> TensorId{
           return opset.cumsum(args,
                               exclusive,
                               reverse,
                               name);
       },
       py::arg("args"),
       py::arg("exclusive") = 0,
       py::arg("reverse") = 0,
       py::arg("debugPrefix") = std::string())
  .def("depthtospace",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          int64_t blocksize,
          const std::string& mode,
          const std::string &name) -> TensorId{
           return opset.depthtospace(args,
                                     blocksize,
                                     mode,
                                     name);
       },
       py::arg("args"),
       py::arg("blocksize"),
       py::arg("mode") = "DCR",
       py::arg("debugPrefix") = std::string())
  .def("dequantizelinear",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.dequantizelinear(args,
                                         name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("det",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.det(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("div",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.div(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("dropout",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          float ratio,
          const std::string &name) -> std::vector<TensorId>{
           return opset.dropout(args,
                                num_outputs,
                                ratio,
                                name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("ratio") = 0.5f,
       py::arg("debugPrefix") = std::string())
  .def("dynamicquantizelinear",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> std::vector<TensorId>{
           return opset.dynamicquantizelinear(args,
                                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("elu",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          float alpha,
          const std::string &name) -> TensorId{
           return opset.elu(args,
                            alpha,
                            name);
       },
       py::arg("args"),
       py::arg("alpha") = 1.0f,
       py::arg("debugPrefix") = std::string())
  .def("equal",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.equal(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("erf",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.erf(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("exp",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.exp(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("expand",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.expand(args,
                               name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("eyelike",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<int64_t> dtype,
          int64_t k,
          const std::string &name) -> TensorId{
           return opset.eyelike(args,
                                dtype,
                                k,
                                name);
       },
       py::arg("args"),
       py::arg("dtype") = nonstd::optional<int64_t>(),
       py::arg("k") = 0,
       py::arg("debugPrefix") = std::string())
  .def("flatten",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.flatten(args,
                                axis,
                                name);
       },
       py::arg("args"),
       py::arg("axis") = 1,
       py::arg("debugPrefix") = std::string())
  .def("floor",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.floor(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("gru",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const std::vector<float>& activation_alpha,
          const std::vector<float>& activation_beta,
          const std::vector<std::string>& activations,
          nonstd::optional<float> clip,
          const std::string& direction,
          nonstd::optional<int64_t> hidden_size,
          int64_t linear_before_reset,
          const std::string &name) -> std::vector<TensorId>{
           return opset.gru(args,
                            num_outputs,
                            activation_alpha,
                            activation_beta,
                            activations,
                            clip,
                            direction,
                            hidden_size,
                            linear_before_reset,
                            name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("activation_alpha") = std::vector<float>(),
       py::arg("activation_beta") = std::vector<float>(),
       py::arg("activations") = std::vector<std::string>(),
       py::arg("clip") = nonstd::optional<float>(),
       py::arg("direction") = "forward",
       py::arg("hidden_size") = nonstd::optional<int64_t>(),
       py::arg("linear_before_reset") = 0,
       py::arg("debugPrefix") = std::string())
  .def("gather",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.gather(args,
                               axis,
                               name);
       },
       py::arg("args"),
       py::arg("axis") = 0,
       py::arg("debugPrefix") = std::string())
  .def("gatherelements",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.gatherelements(args,
                                       axis,
                                       name);
       },
       py::arg("args"),
       py::arg("axis") = 0,
       py::arg("debugPrefix") = std::string())
  .def("gathernd",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.gathernd(args,
                                 name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("gemm",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          float alpha,
          float beta,
          int64_t transA,
          int64_t transB,
          const std::string &name) -> TensorId{
           return opset.gemm(args,
                             alpha,
                             beta,
                             transA,
                             transB,
                             name);
       },
       py::arg("args"),
       py::arg("alpha") = 1.0f,
       py::arg("beta") = 1.0f,
       py::arg("transA") = 0,
       py::arg("transB") = 0,
       py::arg("debugPrefix") = std::string())
  .def("globalaveragepool",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.globalaveragepool(args,
                                          name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("globallppool",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          int64_t p,
          const std::string &name) -> TensorId{
           return opset.globallppool(args,
                                     p,
                                     name);
       },
       py::arg("args"),
       py::arg("p") = 2,
       py::arg("debugPrefix") = std::string())
  .def("globalmaxpool",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.globalmaxpool(args,
                                      name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("greater",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.greater(args,
                                name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("hardsigmoid",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          float alpha,
          float beta,
          const std::string &name) -> TensorId{
           return opset.hardsigmoid(args,
                                    alpha,
                                    beta,
                                    name);
       },
       py::arg("args"),
       py::arg("alpha") = 0.2f,
       py::arg("beta") = 0.5f,
       py::arg("debugPrefix") = std::string())
  .def("hardmax",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.hardmax(args,
                                axis,
                                name);
       },
       py::arg("args"),
       py::arg("axis") = 1,
       py::arg("debugPrefix") = std::string())
  .def("identity",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.identity(args,
                                 name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("logical_if",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const Builder& else_branch,
          const Builder& then_branch,
          const std::string &name) -> std::vector<TensorId>{
           return opset.logical_if(args,
                                   num_outputs,
                                   else_branch,
                                   then_branch,
                                   name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("else_branch"),
       py::arg("then_branch"),
       py::arg("debugPrefix") = std::string())
  .def("instancenormalization",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          float epsilon,
          const std::string &name) -> TensorId{
           return opset.instancenormalization(args,
                                              epsilon,
                                              name);
       },
       py::arg("args"),
       py::arg("epsilon") = 1e-05f,
       py::arg("debugPrefix") = std::string())
  .def("isinf",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          int64_t detect_negative,
          int64_t detect_positive,
          const std::string &name) -> TensorId{
           return opset.isinf(args,
                              detect_negative,
                              detect_positive,
                              name);
       },
       py::arg("args"),
       py::arg("detect_negative") = 1,
       py::arg("detect_positive") = 1,
       py::arg("debugPrefix") = std::string())
  .def("isnan",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.isnan(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("lrn",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          int64_t size,
          float alpha,
          float beta,
          float bias,
          const std::string &name) -> TensorId{
           return opset.lrn(args,
                            size,
                            alpha,
                            beta,
                            bias,
                            name);
       },
       py::arg("args"),
       py::arg("size"),
       py::arg("alpha") = 0.0001f,
       py::arg("beta") = 0.75f,
       py::arg("bias") = 1.0f,
       py::arg("debugPrefix") = std::string())
  .def("lstm",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const std::vector<float>& activation_alpha,
          const std::vector<float>& activation_beta,
          const std::vector<std::string>& activations,
          nonstd::optional<float> clip,
          const std::string& direction,
          nonstd::optional<int64_t> hidden_size,
          int64_t input_forget,
          const std::string &name) -> std::vector<TensorId>{
           return opset.lstm(args,
                             num_outputs,
                             activation_alpha,
                             activation_beta,
                             activations,
                             clip,
                             direction,
                             hidden_size,
                             input_forget,
                             name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("activation_alpha") = std::vector<float>(),
       py::arg("activation_beta") = std::vector<float>(),
       py::arg("activations") = std::vector<std::string>(),
       py::arg("clip") = nonstd::optional<float>(),
       py::arg("direction") = "forward",
       py::arg("hidden_size") = nonstd::optional<int64_t>(),
       py::arg("input_forget") = 0,
       py::arg("debugPrefix") = std::string())
  .def("leakyrelu",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          float alpha,
          const std::string &name) -> TensorId{
           return opset.leakyrelu(args,
                                  alpha,
                                  name);
       },
       py::arg("args"),
       py::arg("alpha") = 0.01f,
       py::arg("debugPrefix") = std::string())
  .def("less",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.less(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("log",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.log(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("logsoftmax",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.logsoftmax(args,
                                   axis,
                                   name);
       },
       py::arg("args"),
       py::arg("axis") = 1,
       py::arg("debugPrefix") = std::string())
  .def("loop",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const Builder& body,
          const std::string &name) -> std::vector<TensorId>{
           return opset.loop(args,
                             num_outputs,
                             body,
                             name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("body"),
       py::arg("debugPrefix") = std::string())
  .def("lpnormalization",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          int64_t p,
          const std::string &name) -> TensorId{
           return opset.lpnormalization(args,
                                        axis,
                                        p,
                                        name);
       },
       py::arg("args"),
       py::arg("axis") = -1,
       py::arg("p") = 2,
       py::arg("debugPrefix") = std::string())
  .def("lppool",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& kernel_shape,
          int64_t p,
          const std::vector<int64_t>& pads,
          const std::vector<int64_t>& strides,
          const std::string &name) -> TensorId{
           return opset.lppool(args,
                               kernel_shape,
                               p,
                               pads,
                               strides,
                               name);
       },
       py::arg("args"),
       py::arg("kernel_shape"),
       py::arg("p") = 2,
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("matmul",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.matmul(args,
                               name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("matmulinteger",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.matmulinteger(args,
                                      name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("max",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.max(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("maxpool",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const std::vector<int64_t>& kernel_shape,
          int64_t ceil_mode,
          const std::vector<int64_t>& dilations,
          const std::vector<int64_t>& pads,
          int64_t storage_order,
          const std::vector<int64_t>& strides,
          const std::string &name) -> std::vector<TensorId>{
           return opset.maxpool(args,
                                num_outputs,
                                kernel_shape,
                                ceil_mode,
                                dilations,
                                pads,
                                storage_order,
                                strides,
                                name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("kernel_shape"),
       py::arg("ceil_mode") = 0,
       py::arg("dilations") = std::vector<int64_t>(),
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("storage_order") = 0,
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("maxroipool",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& pooled_shape,
          float spatial_scale,
          const std::string &name) -> TensorId{
           return opset.maxroipool(args,
                                   pooled_shape,
                                   spatial_scale,
                                   name);
       },
       py::arg("args"),
       py::arg("pooled_shape"),
       py::arg("spatial_scale") = 1.0f,
       py::arg("debugPrefix") = std::string())
  .def("maxunpool",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& kernel_shape,
          const std::vector<int64_t>& pads,
          const std::vector<int64_t>& strides,
          const std::string &name) -> TensorId{
           return opset.maxunpool(args,
                                  kernel_shape,
                                  pads,
                                  strides,
                                  name);
       },
       py::arg("args"),
       py::arg("kernel_shape"),
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("mean",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.mean(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("meanvariancenormalization",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& axes,
          const std::string &name) -> TensorId{
           return opset.meanvariancenormalization(args,
                                                  axes,
                                                  name);
       },
       py::arg("args"),
       py::arg("axes") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("min",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.min(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("mod",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          int64_t fmod,
          const std::string &name) -> TensorId{
           return opset.mod(args,
                            fmod,
                            name);
       },
       py::arg("args"),
       py::arg("fmod") = 0,
       py::arg("debugPrefix") = std::string())
  .def("mul",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.mul(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("multinomial",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          int64_t dtype,
          int64_t sample_size,
          nonstd::optional<float> seed,
          const std::string &name) -> TensorId{
           return opset.multinomial(args,
                                    dtype,
                                    sample_size,
                                    seed,
                                    name);
       },
       py::arg("args"),
       py::arg("dtype") = 6,
       py::arg("sample_size") = 1,
       py::arg("seed") = nonstd::optional<float>(),
       py::arg("debugPrefix") = std::string())
  .def("neg",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.neg(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("nonmaxsuppression",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          int64_t center_point_box,
          const std::string &name) -> TensorId{
           return opset.nonmaxsuppression(args,
                                          center_point_box,
                                          name);
       },
       py::arg("args"),
       py::arg("center_point_box") = 0,
       py::arg("debugPrefix") = std::string())
  .def("nonzero",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.nonzero(args,
                                name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("logical_not",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.logical_not(args,
                                    name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("onehot",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.onehot(args,
                               axis,
                               name);
       },
       py::arg("args"),
       py::arg("axis") = -1,
       py::arg("debugPrefix") = std::string())
  .def("logical_or",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.logical_or(args,
                                   name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("prelu",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.prelu(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("pad",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string& mode,
          const std::string &name) -> TensorId{
           return opset.pad(args,
                            mode,
                            name);
       },
       py::arg("args"),
       py::arg("mode") = "constant",
       py::arg("debugPrefix") = std::string())
  .def("pow",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.pow(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("qlinearconv",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& dilations,
          int64_t group,
          const std::vector<int64_t>& kernel_shape,
          const std::vector<int64_t>& pads,
          const std::vector<int64_t>& strides,
          const std::string &name) -> TensorId{
           return opset.qlinearconv(args,
                                    dilations,
                                    group,
                                    kernel_shape,
                                    pads,
                                    strides,
                                    name);
       },
       py::arg("args"),
       py::arg("dilations") = std::vector<int64_t>(),
       py::arg("group") = 1,
       py::arg("kernel_shape") = std::vector<int64_t>(),
       py::arg("pads") = std::vector<int64_t>(),
       py::arg("strides") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("qlinearmatmul",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.qlinearmatmul(args,
                                      name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("quantizelinear",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.quantizelinear(args,
                                       name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("rnn",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const std::vector<float>& activation_alpha,
          const std::vector<float>& activation_beta,
          const std::vector<std::string>& activations,
          nonstd::optional<float> clip,
          const std::string& direction,
          nonstd::optional<int64_t> hidden_size,
          const std::string &name) -> std::vector<TensorId>{
           return opset.rnn(args,
                            num_outputs,
                            activation_alpha,
                            activation_beta,
                            activations,
                            clip,
                            direction,
                            hidden_size,
                            name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("activation_alpha") = std::vector<float>(),
       py::arg("activation_beta") = std::vector<float>(),
       py::arg("activations") = std::vector<std::string>(),
       py::arg("clip") = nonstd::optional<float>(),
       py::arg("direction") = "forward",
       py::arg("hidden_size") = nonstd::optional<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("randomnormal",
       [](AiOnnxOpset11 &opset,
          const std::vector<int64_t>& shape,
          int64_t dtype,
          float mean,
          float scale,
          nonstd::optional<float> seed,
          const std::string &name) -> TensorId{
           return opset.randomnormal(                                     shape,
                                     dtype,
                                     mean,
                                     scale,
                                     seed,
                                     name);
       },
       py::arg("shape"),
       py::arg("dtype") = 1,
       py::arg("mean") = 0.0f,
       py::arg("scale") = 1.0f,
       py::arg("seed") = nonstd::optional<float>(),
       py::arg("debugPrefix") = std::string())
  .def("randomnormallike",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<int64_t> dtype,
          float mean,
          float scale,
          nonstd::optional<float> seed,
          const std::string &name) -> TensorId{
           return opset.randomnormallike(args,
                                         dtype,
                                         mean,
                                         scale,
                                         seed,
                                         name);
       },
       py::arg("args"),
       py::arg("dtype") = nonstd::optional<int64_t>(),
       py::arg("mean") = 0.0f,
       py::arg("scale") = 1.0f,
       py::arg("seed") = nonstd::optional<float>(),
       py::arg("debugPrefix") = std::string())
  .def("randomuniform",
       [](AiOnnxOpset11 &opset,
          const std::vector<int64_t>& shape,
          int64_t dtype,
          float high,
          float low,
          nonstd::optional<float> seed,
          const std::string &name) -> TensorId{
           return opset.randomuniform(                                      shape,
                                      dtype,
                                      high,
                                      low,
                                      seed,
                                      name);
       },
       py::arg("shape"),
       py::arg("dtype") = 1,
       py::arg("high") = 1.0f,
       py::arg("low") = 0.0f,
       py::arg("seed") = nonstd::optional<float>(),
       py::arg("debugPrefix") = std::string())
  .def("randomuniformlike",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<int64_t> dtype,
          float high,
          float low,
          nonstd::optional<float> seed,
          const std::string &name) -> TensorId{
           return opset.randomuniformlike(args,
                                          dtype,
                                          high,
                                          low,
                                          seed,
                                          name);
       },
       py::arg("args"),
       py::arg("dtype") = nonstd::optional<int64_t>(),
       py::arg("high") = 1.0f,
       py::arg("low") = 0.0f,
       py::arg("seed") = nonstd::optional<float>(),
       py::arg("debugPrefix") = std::string())
  .def("range",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.range(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("reciprocal",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.reciprocal(args,
                                   name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("reducel1",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducel1(args,
                                 axes,
                                 keepdims,
                                 name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducel2",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducel2(args,
                                 axes,
                                 keepdims,
                                 name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducelogsum",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducelogsum(args,
                                     axes,
                                     keepdims,
                                     name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducelogsumexp",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducelogsumexp(args,
                                        axes,
                                        keepdims,
                                        name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducemax",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducemax(args,
                                  axes,
                                  keepdims,
                                  name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducemean",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducemean(args,
                                   axes,
                                   keepdims,
                                   name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducemin",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducemin(args,
                                  axes,
                                  keepdims,
                                  name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reduceprod",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reduceprod(args,
                                   axes,
                                   keepdims,
                                   name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducesum",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducesum(args,
                                  axes,
                                  keepdims,
                                  name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("reducesumsquare",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          nonstd::optional<std::vector<int64_t>> axes,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.reducesumsquare(args,
                                        axes,
                                        keepdims,
                                        name);
       },
       py::arg("args"),
       py::arg("axes") = nonstd::optional<std::vector<int64_t>>(),
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("relu",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.relu(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("reshape",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.reshape(args,
                                name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("resize",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string& coordinate_transformation_mode,
          float cubic_coeff_a,
          int64_t exclude_outside,
          float extrapolation_value,
          const std::string& mode,
          const std::string& nearest_mode,
          const std::string &name) -> TensorId{
           return opset.resize(args,
                               coordinate_transformation_mode,
                               cubic_coeff_a,
                               exclude_outside,
                               extrapolation_value,
                               mode,
                               nearest_mode,
                               name);
       },
       py::arg("args"),
       py::arg("coordinate_transformation_mode") = "half_pixel",
       py::arg("cubic_coeff_a") = -0.75f,
       py::arg("exclude_outside") = 0,
       py::arg("extrapolation_value") = 0.0f,
       py::arg("mode") = "nearest",
       py::arg("nearest_mode") = "round_prefer_floor",
       py::arg("debugPrefix") = std::string())
  .def("reversesequence",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          int64_t batch_axis,
          int64_t time_axis,
          const std::string &name) -> TensorId{
           return opset.reversesequence(args,
                                        batch_axis,
                                        time_axis,
                                        name);
       },
       py::arg("args"),
       py::arg("batch_axis") = 1,
       py::arg("time_axis") = 0,
       py::arg("debugPrefix") = std::string())
  .def("roialign",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string& mode,
          int64_t output_height,
          int64_t output_width,
          int64_t sampling_ratio,
          float spatial_scale,
          const std::string &name) -> TensorId{
           return opset.roialign(args,
                                 mode,
                                 output_height,
                                 output_width,
                                 sampling_ratio,
                                 spatial_scale,
                                 name);
       },
       py::arg("args"),
       py::arg("mode") = "avg",
       py::arg("output_height") = 1,
       py::arg("output_width") = 1,
       py::arg("sampling_ratio") = 0,
       py::arg("spatial_scale") = 1.0f,
       py::arg("debugPrefix") = std::string())
  .def("round",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.round(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("scan",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          const Builder& body,
          int64_t num_scan_inputs,
          const std::vector<int64_t>& scan_input_axes,
          const std::vector<int64_t>& scan_input_directions,
          const std::vector<int64_t>& scan_output_axes,
          const std::vector<int64_t>& scan_output_directions,
          const std::string &name) -> std::vector<TensorId>{
           return opset.scan(args,
                             num_outputs,
                             body,
                             num_scan_inputs,
                             scan_input_axes,
                             scan_input_directions,
                             scan_output_axes,
                             scan_output_directions,
                             name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("body"),
       py::arg("num_scan_inputs"),
       py::arg("scan_input_axes") = std::vector<int64_t>(),
       py::arg("scan_input_directions") = std::vector<int64_t>(),
       py::arg("scan_output_axes") = std::vector<int64_t>(),
       py::arg("scan_output_directions") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("scatter",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.scatter(args,
                                axis,
                                name);
       },
       py::arg("args"),
       py::arg("axis") = 0,
       py::arg("debugPrefix") = std::string())
  .def("scatterelements",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.scatterelements(args,
                                        axis,
                                        name);
       },
       py::arg("args"),
       py::arg("axis") = 0,
       py::arg("debugPrefix") = std::string())
  .def("scatternd",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.scatternd(args,
                                  name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("selu",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          float alpha,
          float gamma,
          const std::string &name) -> TensorId{
           return opset.selu(args,
                             alpha,
                             gamma,
                             name);
       },
       py::arg("args"),
       py::arg("alpha") = 1.67326f,
       py::arg("gamma") = 1.0507f,
       py::arg("debugPrefix") = std::string())
  .def("sequenceat",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sequenceat(args,
                                   name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("sequenceconstruct",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sequenceconstruct(args,
                                          name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("sequenceempty",
       [](AiOnnxOpset11 &opset,
          nonstd::optional<int64_t> dtype,
          const std::string &name) -> TensorId{
           return opset.sequenceempty(                                      dtype,
                                      name);
       },
       py::arg("dtype") = nonstd::optional<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("sequenceerase",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sequenceerase(args,
                                      name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("sequenceinsert",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sequenceinsert(args,
                                       name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("sequencelength",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sequencelength(args,
                                       name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("shape",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.shape(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("shrink",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          float bias,
          float lambd,
          const std::string &name) -> TensorId{
           return opset.shrink(args,
                               bias,
                               lambd,
                               name);
       },
       py::arg("args"),
       py::arg("bias") = 0.0f,
       py::arg("lambd") = 0.5f,
       py::arg("debugPrefix") = std::string())
  .def("sigmoid",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sigmoid(args,
                                name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("sign",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sign(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("sin",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sin(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("sinh",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sinh(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("size",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.size(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("slice",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.slice(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("softmax",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          const std::string &name) -> TensorId{
           return opset.softmax(args,
                                axis,
                                name);
       },
       py::arg("args"),
       py::arg("axis") = 1,
       py::arg("debugPrefix") = std::string())
  .def("softplus",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.softplus(args,
                                 name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("softsign",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.softsign(args,
                                 name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("spacetodepth",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          int64_t blocksize,
          const std::string &name) -> TensorId{
           return opset.spacetodepth(args,
                                     blocksize,
                                     name);
       },
       py::arg("args"),
       py::arg("blocksize"),
       py::arg("debugPrefix") = std::string())
  .def("split",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          int64_t axis,
          const std::vector<int64_t>& split,
          const std::string &name) -> std::vector<TensorId>{
           return opset.split(args,
                              num_outputs,
                              axis,
                              split,
                              name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("axis") = 0,
       py::arg("split") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("splittosequence",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          int64_t keepdims,
          const std::string &name) -> TensorId{
           return opset.splittosequence(args,
                                        axis,
                                        keepdims,
                                        name);
       },
       py::arg("args"),
       py::arg("axis") = 0,
       py::arg("keepdims") = 1,
       py::arg("debugPrefix") = std::string())
  .def("sqrt",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sqrt(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("squeeze",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& axes,
          const std::string &name) -> TensorId{
           return opset.squeeze(args,
                                axes,
                                name);
       },
       py::arg("args"),
       py::arg("axes") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("stringnormalizer",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string& case_change_action,
          int64_t is_case_sensitive,
          nonstd::optional<std::string> locale,
          const std::vector<std::string>& stopwords,
          const std::string &name) -> TensorId{
           return opset.stringnormalizer(args,
                                         case_change_action,
                                         is_case_sensitive,
                                         locale,
                                         stopwords,
                                         name);
       },
       py::arg("args"),
       py::arg("case_change_action") = "NONE",
       py::arg("is_case_sensitive") = 0,
       py::arg("locale") = std::string(),
       py::arg("stopwords") = std::vector<std::string>(),
       py::arg("debugPrefix") = std::string())
  .def("sub",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sub(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("sum",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.sum(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("tan",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.tan(args,
                            name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("tanh",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.tanh(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("tfidfvectorizer",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          int64_t max_gram_length,
          int64_t max_skip_count,
          int64_t min_gram_length,
          const std::string& mode,
          const std::vector<int64_t>& ngram_counts,
          const std::vector<int64_t>& ngram_indexes,
          const std::vector<int64_t>& pool_int64s,
          const std::vector<std::string>& pool_strings,
          const std::vector<float>& weights,
          const std::string &name) -> TensorId{
           return opset.tfidfvectorizer(args,
                                        max_gram_length,
                                        max_skip_count,
                                        min_gram_length,
                                        mode,
                                        ngram_counts,
                                        ngram_indexes,
                                        pool_int64s,
                                        pool_strings,
                                        weights,
                                        name);
       },
       py::arg("args"),
       py::arg("max_gram_length"),
       py::arg("max_skip_count"),
       py::arg("min_gram_length"),
       py::arg("mode"),
       py::arg("ngram_counts"),
       py::arg("ngram_indexes"),
       py::arg("pool_int64s") = std::vector<int64_t>(),
       py::arg("pool_strings") = std::vector<std::string>(),
       py::arg("weights") = std::vector<float>(),
       py::arg("debugPrefix") = std::string())
  .def("thresholdedrelu",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          float alpha,
          const std::string &name) -> TensorId{
           return opset.thresholdedrelu(args,
                                        alpha,
                                        name);
       },
       py::arg("args"),
       py::arg("alpha") = 1.0f,
       py::arg("debugPrefix") = std::string())
  .def("tile",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.tile(args,
                             name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("topk",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          int64_t axis,
          int64_t largest,
          int64_t sorted,
          const std::string &name) -> std::vector<TensorId>{
           return opset.topk(args,
                             axis,
                             largest,
                             sorted,
                             name);
       },
       py::arg("args"),
       py::arg("axis") = -1,
       py::arg("largest") = 1,
       py::arg("sorted") = 1,
       py::arg("debugPrefix") = std::string())
  .def("transpose",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& perm,
          const std::string &name) -> TensorId{
           return opset.transpose(args,
                                  perm,
                                  name);
       },
       py::arg("args"),
       py::arg("perm") = std::vector<int64_t>(),
       py::arg("debugPrefix") = std::string())
  .def("unique",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          unsigned num_outputs,
          nonstd::optional<int64_t> axis,
          int64_t sorted,
          const std::string &name) -> std::vector<TensorId>{
           return opset.unique(args,
                               num_outputs,
                               axis,
                               sorted,
                               name);
       },
       py::arg("args"),
       py::arg("num_outputs"),
       py::arg("axis") = nonstd::optional<int64_t>(),
       py::arg("sorted") = 1,
       py::arg("debugPrefix") = std::string())
  .def("unsqueeze",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::vector<int64_t>& axes,
          const std::string &name) -> TensorId{
           return opset.unsqueeze(args,
                                  axes,
                                  name);
       },
       py::arg("args"),
       py::arg("axes"),
       py::arg("debugPrefix") = std::string())
  .def("upsample",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string& mode,
          const std::string &name) -> TensorId{
           return opset.upsample(args,
                                 mode,
                                 name);
       },
       py::arg("args"),
       py::arg("mode") = "nearest",
       py::arg("debugPrefix") = std::string())
  .def("where",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.where(args,
                              name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
  .def("logical_xor",
       [](AiOnnxOpset11 &opset,
          const std::vector<TensorId> &args,
          const std::string &name) -> TensorId{
           return opset.logical_xor(args,
                                    name);
       },
       py::arg("args"),
       py::arg("debugPrefix") = std::string())
;
